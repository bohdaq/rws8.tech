<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Mastering JavaScript: Essential Concepts for Modern Developers</title>
    <meta name="author" content="Bohdan Tsap" />
    <meta name="description"
        content="A comprehensive guide to essential JavaScript concepts including data types, hoisting, closures, currying, this keyword, promises, and generators." />
    <style type="text/css">
        /* Page setup for 6" x 9" trim size */
        @page {
            size: 6in 9in;
            margin: 0.5in 0.5in 0.5in 0.875in;
            /* top, right, bottom, left - left is gutter for compatibility */
        }

        @page :left {
            margin-top: 0.5in;
            margin-bottom: 0.5in;
            margin-left: 0.875in;
            /* Inside/gutter margin for left pages - exceeds 0.625" requirement */
            margin-right: 0.5in;
            /* Outside margin for left pages - exceeds 0.25" minimum */
        }

        @page :right {
            margin-top: 0.5in;
            margin-bottom: 0.5in;
            margin-left: 0.5in;
            /* Outside margin for right pages - exceeds 0.25" minimum */
            margin-right: 0.875in;
            /* Inside/gutter margin for right pages - exceeds 0.625" requirement */
        }

        body {
            font-family: Georgia, serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }

        h1 {
            font-size: 2em;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            page-break-before: always;
        }

        h2 {
            font-size: 1.5em;
            margin-top: 1.2em;
            margin-bottom: 0.5em;
        }

        h3 {
            font-size: 1.2em;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }

        h4 {
            font-size: 1em;
            margin-top: 0.8em;
            margin-bottom: 0.5em;
            font-weight: bold;
        }

        p {
            margin: 0.5em 0;
            text-align: justify;
        }

        code {
            font-family: "Courier New", monospace;
            background-color: #f4f4f4;
            padding: 0.1em 0.3em;
            font-size: 0.85em;
            color: #000;
        }

        pre {
            background-color: #f4f4f4;
            padding: 0.8em;
            margin: 0.8em 0;
            border: 1px solid #ddd;
            page-break-inside: avoid;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
            overflow: visible;
        }

        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 0.85em;
            line-height: 1.4;
            color: #000;
            display: block;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Print-specific styles */
        @media print {
            pre {
                white-space: pre-wrap !important;
                word-wrap: break-word !important;
                overflow-wrap: break-word !important;
            }

            pre code {
                white-space: pre-wrap !important;
                word-break: break-word !important;
            }
        }

        /* Simplified syntax highlighting for Kindle compatibility */
        .keyword {
            font-weight: bold;
        }

        .comment {
            color: #666;
            font-style: italic;
        }

        .string {
            color: #333;
        }

        ul,
        ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        li {
            margin: 0.3em 0;
        }

        strong {
            font-weight: bold;
        }

        em {
            font-style: italic;
        }

        .toc {
            margin: 2em 0;
        }

        .toc ul {
            list-style-type: none;
            padding-left: 1em;
        }

        .toc li {
            margin: 0.5em 0;
        }

        .page-break {
            page-break-after: always;
        }

        .center {
            text-align: center;
        }

        .copyright {
            font-size: 0.9em;
            margin-top: 3em;
            text-align: center;
        }
    </style>
</head>

<body>

    <!-- Title Page -->
    <div class="center page-break">
        <h1 style="margin-top: 3em;">Mastering JavaScript</h1>
        <h2>Essential Concepts for Modern Developers</h2>
        <p style="margin-top: 2em;"><strong>By Bohdan Tsap</strong></p>
    </div>

    <!-- Copyright Page -->
    <div class="page-break">
        <p><strong>Mastering JavaScript: Essential Concepts for Modern Developers</strong></p>
        <p>Copyright Â© 2026 Bohdan Tsap</p>
        <p>All rights reserved.</p>
        <p style="margin-top: 2em;">No part of this book may be reproduced or transmitted in any form or by any means,
            electronic or mechanical, including photocopying, recording, or by any information storage and retrieval
            system, without written permission from the author.</p>
        <p style="margin-top: 2em;">Published by Bohdan Tsap</p>
    </div>

    <!-- About the Book -->
    <div class="page-break">
        <h1>About This Book</h1>
        <p>This book is a curated collection of essential JavaScript concepts that every developer should master. Each
            chapter is designed as a quick, practical guide to help you understand and apply these concepts in
            real-world scenarios.</p>
        <p>Whether you're a beginner looking to build a solid foundation or an experienced developer wanting to fill
            knowledge gaps, this book provides clear explanations, practical examples, and best practices for modern
            JavaScript development.</p>
    </div>

    <!-- Table of Contents -->
    <nav id="toc" class="toc page-break" epub:type="toc" role="doc-toc">
        <h1>Table of Contents</h1>

        <ol>
            <li>Introduction</li>
            <li>
                <strong>Part I: JavaScript Fundamentals</strong>
                <ol>
                    <li>Chapter 1: JavaScript Data Types</li>
                    <li>Chapter 2: JavaScript Variables and Scope</li>
                    <li>Chapter 3: JavaScript Functions</li>
                    <li>Chapter 4: JavaScript Hoisting</li>
                </ol>
            </li>
            <li>
                <strong>Part II: Advanced Functions</strong>
                <ul>
                    <li>Chapter 5: JavaScript Closures</li>
                    <li>Chapter 6: JavaScript 'this' Keyword</li>
                    <li>Chapter 7: JavaScript Currying</li>
                </ul>
            </li>
            <li>
                <strong>Part III: Object-Oriented JavaScript</strong>
                <ol>
                    <li>Chapter 8: JavaScript Encapsulation</li>
                    <li>Chapter 9: JavaScript Inheritance</li>
                    <li>Chapter 10: JavaScript Polymorphism</li>
                    <li>Chapter 11: JavaScript Classes</li>
                </ol>
            </li>
            <li>
                <strong>Part IV: Asynchronous JavaScript</strong>
                <ul>
                    <li>Chapter 12: JavaScript Event Loop</li>
                    <li>Chapter 13: JavaScript Promises</li>
                    <li>Chapter 14: JavaScript async/await</li>
                    <li>Chapter 15: JavaScript Generators</li>
                </ul>
            </li>
            <li>
                <strong>Part V: Modern JavaScript Syntax</strong>
                <ol>
                    <li>Chapter 16: JavaScript Destructuring</li>
                    <li>Chapter 17: JavaScript Spread and Rest Operators</li>
                    <li>Chapter 18: JavaScript Optional Chaining</li>
                    <li>Chapter 19: JavaScript Modules</li>
                </ol>
            </li>
            <li>
                <strong>Part VI: Browser APIs and DOM</strong>
                <ul>
                    <li>Chapter 20: JavaScript DOM Manipulation</li>
                    <li>Chapter 21: JavaScript Event Handling</li>
                    <li>Chapter 22: JavaScript LocalStorage</li>
                    <li>Chapter 23: JavaScript Fetch API</li>
                    <li>Chapter 24: JavaScript IntersectionObserver</li>
                </ul>
            </li>
            <li>
                <strong>Part VII: Algorithms and Data Structures</strong>
                <ul>
                    <li>Chapter 25: JavaScript Arrays and Array Methods</li>
                    <li>Chapter 26: JavaScript Stacks and Queues</li>
                    <li>Chapter 27: JavaScript Linked Lists</li>
                    <li>Chapter 28: JavaScript Trees and Binary Search Trees</li>
                    <li>Chapter 29: JavaScript Hash Tables and Maps</li>
                    <li>Chapter 30: JavaScript Sorting Algorithms</li>
                    <li>Chapter 31: JavaScript Searching Algorithms</li>
                </ul>
            </li>
            <li>
                <strong>Part VIII: Design Patterns</strong>
                <ul>
                    <li>Chapter 32: JavaScript Singleton Pattern</li>
                    <li>Chapter 33: JavaScript Factory Pattern</li>
                    <li>Chapter 34: JavaScript Observer Pattern</li>
                    <li>Chapter 35: JavaScript Builder Pattern</li>
                    <li>Chapter 36: JavaScript Module Pattern</li>
                    <li>Chapter 37: JavaScript Decorator Pattern</li>
                    <li>Chapter 38: JavaScript Facade Pattern</li>
                    <li>Chapter 39: JavaScript Strategy Pattern</li>
                    <li>Chapter 40: JavaScript Command Pattern</li>
                </ul>
            </li>
            <li>
                <strong>Part IX: Advanced JavaScript Features</strong>
                <ul>
                    <li>Chapter 41: JavaScript Symbols</li>
                    <li>Chapter 42: JavaScript BigInt</li>
                    <li>Chapter 43: JavaScript Error Handling</li>
                    <li>Chapter 44: JavaScript Regular Expressions</li>
                    <li>Chapter 45: JavaScript Typed Arrays</li>
                    <li>Chapter 46: JavaScript Iterators</li>
                    <li>Chapter 47: JavaScript Proxies</li>
                </ul>
            </li>
            <li>
                <strong>Part X: Functional JavaScript</strong>
                <ul>
                    <li>Chapter 48: JavaScript Immutability</li>
                    <li>Chapter 49: JavaScript Function Composition</li>
                    <li>Chapter 50: JavaScript Functors and Applicatives</li>
                    <li>Chapter 51: JavaScript Monads</li>
                </ul>
            </li>
            <li>
                <strong>Part XI: Testing</strong>
                <ul>
                    <li>Chapter 52: JavaScript Unit Testing</li>
                    <li>Chapter 53: JavaScript Test-Driven Development</li>
                    <li>Chapter 54: JavaScript Mocking</li>
                    <li>Chapter 55: JavaScript Integration Testing</li>
                    <li>Chapter 56: JavaScript End-to-End Testing</li>
                </ul>
            </li>
            <li>Conclusion</li>
            <li>About the Author</li>
        </ol>
    </nav>

    <!-- Introduction -->
    <div id="introduction" class="page-break">
        <h1>Introduction</h1>

        <p>JavaScript has evolved from a simple scripting language into one of the most powerful and versatile
            programming languages in the world. It powers everything from interactive websites to server-side
            applications, mobile apps, and even desktop software.</p>

        <p>But with great power comes great complexity. JavaScript has quirks, features, and patterns that can confuse
            even experienced developers. This book cuts through the confusion and focuses on the essential concepts you
            need to write clean, efficient, and maintainable JavaScript code.</p>

        <p>Each chapter in this book is designed to be read in about 3 minutes, making it perfect for busy developers
            who want to learn on the go. But don't let the brevity fool you - these chapters are packed with practical
            insights, real-world examples, and best practices that you can apply immediately.</p>

        <h3>Who This Book Is For</h3>
        <ul>
            <li><strong>Beginners</strong> who want to build a solid foundation in JavaScript</li>
            <li><strong>Intermediate developers</strong> looking to deepen their understanding</li>
            <li><strong>Experienced developers</strong> who want to fill knowledge gaps</li>
            <li><strong>Anyone</strong> preparing for technical interviews</li>
        </ul>

        <h3>How to Use This Book</h3>
        <p>You can read this book from cover to cover, or jump to specific chapters that interest you. Each chapter is
            self-contained, so you can learn at your own pace.</p>

        <p>I recommend keeping this book handy as a reference. When you encounter a confusing JavaScript behavior,
            chances are there's a chapter here that explains it.</p>

        <p>Let's dive in!</p>
    </div>

    <!-- PART I -->
    <div class="page-break">
        <h1 class="center">Part I</h1>
        <h2 class="center">JavaScript Fundamentals</h2>
    </div>


    <!-- PART I -->
    <div class="page-break">
        <h1 class="center">Part I</h1>
        <h2 class="center">JavaScript Fundamentals</h2>
    </div>

    <!-- Chapter 1 -->
    <div id="chapter1" class="page-break">
        <h1>Chapter 1: JavaScript Data Types</h1>
        <h2>Everything You Need to Know</h2>

        <p>Data types are the foundation of any programming language. In JavaScript, understanding types isn't just
            academic - it's essential for avoiding bugs and writing reliable code. Every value in JavaScript has a type,
            and that type determines what operations you can perform on it, how it's stored in memory, and how it
            behaves
            when you pass it around your program.</p>

        <p>Many JavaScript bugs stem from misunderstanding how types work. You might have encountered situations where
            adding two numbers gives you an unexpected string, or where comparing values doesn't work the way you
            expect.
            These aren't random quirks - they're predictable behaviors once you understand JavaScript's type system.</p>

        <p>In this chapter, we'll explore JavaScript's type system from the ground up. By the end, you'll understand
            not just what the types are, but why they behave the way they do and how to use them effectively in your
            code.</p>

        <h3>Two Categories: Primitives and Objects</h3>
        <p>JavaScript organizes its data types into two fundamental categories, and understanding this distinction is
            crucial to mastering the language:</p>
        <ol>
            <li><strong>Primitives</strong> - Immutable values (7 types)</li>
            <li><strong>Objects</strong> - Mutable collections (everything else)</li>
        </ol>

        <p>This distinction matters because primitives and objects behave fundamentally differently in three key ways:
        </p>
        <p><strong>Memory storage:</strong> Primitives are stored directly in the variable, while objects are stored
            as references. This affects how they're copied and compared.</p>
        <p><strong>Mutability:</strong> Primitives are immutable - you can't change them, only replace them. Objects
            are mutable - you can modify their contents without creating a new object.</p>
        <p><strong>Comparison:</strong> Primitives are compared by value, while objects are compared by reference.
            Two objects with identical contents are not considered equal unless they're the same object.</p>

        <p>Let's explore each primitive type in detail, understanding not just what they are, but when and how to use
            them.</p>

        <h3>The Seven Primitive Types</h3>

        <h4>1. Number</h4>
        <p>Unlike many programming languages that have separate types for integers and floating-point numbers,
            JavaScript
            simplifies things with a single Number type. All numbers in JavaScript are 64-bit floating-point values,
            following the IEEE 754 standard. This means whether you write <code>42</code> or <code>42.0</code>,
            JavaScript
            treats them the same way.</p>

        <p>This design choice makes JavaScript easier to learn, but it comes with some quirks you need to understand:
        </p>

        <pre><code class="language-javascript">let age = 25;           // Integer
let price = 19.99;      // Float
let infinity = Infinity;
let notANumber = NaN;

console.log(0.1 + 0.2); // 0.30000000000000004 (!)
console.log(5 / 0);     // Infinity</code></pre>

        <p>The infamous <code>0.1 + 0.2</code> example demonstrates floating-point precision issues. This isn't a
            JavaScript
            bug - it's how binary floating-point math works in all programming languages. When you need precise decimal
            arithmetic (like for financial calculations), use libraries like decimal.js or store values as integers
            (cents instead of dollars).</p>

        <p>JavaScript also has special numeric values: <code>Infinity</code> represents numbers too large to represent,
            <code>-Infinity</code> for numbers too small, and <code>NaN</code> (Not a Number) for invalid mathematical
            operations. Interestingly, <code>NaN</code> is the only value in JavaScript that's not equal to itself:
            <code>NaN === NaN</code> returns <code>false</code>. Use <code>Number.isNaN()</code> to check for it.
        </p>

        <p><strong>Practical tip:</strong> When displaying numbers to users, use <code>toFixed()</code> to control
            decimal places, or <code>toLocaleString()</code> for proper formatting with thousands separators and
            currency symbols.</p>

        <h4>2. String</h4>
        <p>Strings represent text in JavaScript and are one of the most commonly used types. They're sequences of
            characters enclosed in single quotes, double quotes, or backticks. While the first two are functionally
            identical, backticks (template literals) offer powerful features like string interpolation and multi-line
            strings.</p>

        <p>A crucial characteristic of strings is that they're <strong>immutable</strong>. Once created, a string's
            contents cannot be changed. When you perform operations on strings, JavaScript creates new strings rather
            than modifying existing ones. This immutability might seem inefficient, but it enables important
            optimizations
            and makes strings safer to use.</p>

        <pre><code class="language-javascript">let name = "Alice";
let greeting = `Hello, ${name}!`; // Template literal

// Strings are immutable
name[0] = "B";
console.log(name); // Still "Alice"</code></pre>

        <p>In the example above, trying to change the first character of <code>name</code> fails silently (or throws
            an error in strict mode). If you need to modify a string, you must create a new one. Methods like
            <code>toUpperCase()</code>, <code>slice()</code>, and <code>replace()</code> all return new strings,
            leaving the original unchanged.
        </p>

        <p>Template literals (the backtick syntax) revolutionized string handling in JavaScript. They allow you to
            embed expressions directly in strings using <code>${expression}</code>, making string concatenation much
            more readable than the old <code>"Hello, " + name + "!"</code> approach.</p>

        <h4>3. Boolean</h4>
        <p>At first glance, Booleans seem simple: they're either <code>true</code> or <code>false</code>. You use them
            for conditional logic, flags, and state management. However, JavaScript's Boolean type has a subtle
            complexity
            that trips up many developers: the concept of "truthy" and "falsy" values.</p>

        <p>In JavaScript, every value has an inherent Boolean quality. When used in a Boolean context (like an
            <code>if</code>
            statement), values are coerced to either <code>true</code> or <code>false</code>. This automatic conversion
            can be convenient, but it's also a common source of bugs if you don't understand which values are falsy.
        </p>

        <pre><code class="language-javascript">let isActive = true;
let isComplete = false;

// But watch out for truthy/falsy values
if ("") {
    // Won't run - empty string is falsy
}

if ("hello") {
    // Will run - non-empty strings are truthy
}</code></pre>

        <p>There are exactly <strong>six falsy values</strong> in JavaScript: <code>false</code>, <code>0</code>,
            <code>""</code> (empty string), <code>null</code>, <code>undefined</code>, and <code>NaN</code>. Everything
            else is truthy - and this includes some values that might surprise you.
        </p>

        <p>Empty arrays <code>[]</code> and empty objects <code>{}</code> are truthy, even though they contain nothing.
            The string <code>"0"</code> is truthy, even though the number <code>0</code> is falsy. These distinctions
            matter when writing conditional logic. If you need to check if an array is empty, don't rely on truthiness -
            check its <code>length</code> property explicitly.</p>

        <h4>4. Undefined</h4>
        <p>The <code>undefined</code> type represents the absence of a value, but in a specific way: it means a variable
            has been declared but not yet assigned a value. JavaScript automatically assigns <code>undefined</code> to
            variables you declare without initializing, and functions return <code>undefined</code> if they don't
            explicitly return something else.</p>

        <pre><code class="language-javascript">let x;
console.log(x); // undefined

function noReturn() {}
console.log(noReturn()); // undefined</code></pre>

        <p>You'll also encounter <code>undefined</code> when accessing object properties that don't exist, or array
            elements beyond the array's length. Understanding <code>undefined</code> helps you distinguish between
            "this variable exists but has no value" and "this property doesn't exist at all."</p>

        <p>A common pattern is to check if a variable is <code>undefined</code> before using it, though modern
            JavaScript
            offers better alternatives like default parameters and optional chaining (<code>?.</code>).</p>

        <h4>5. Null</h4>
        <p>While <code>undefined</code> represents an unintentional absence of value, <code>null</code> represents an
            <strong>intentional</strong> absence. You use <code>null</code> when you want to explicitly indicate that
            a variable should be empty. It's a way of saying "I've thought about this, and this variable should have
            no value right now."
        </p>

        <pre><code class="language-javascript">let user = null; // Explicitly empty

// Historical bug:
console.log(typeof null); // "object" (should be "null")</code></pre>

        <p>There's a famous bug in JavaScript: <code>typeof null</code> returns <code>"object"</code> instead of
            <code>"null"</code>. This bug has existed since JavaScript's creation and can't be fixed without breaking
            millions of websites. When checking for <code>null</code>, use strict equality: <code>value === null</code>.
        </p>

        <p>The distinction between <code>null</code> and <code>undefined</code> is subtle but important. Use
            <code>undefined</code> for variables that haven't been initialized, and <code>null</code> for variables
            that you're explicitly setting to "no value." For example, if a user hasn't selected a profile picture,
            you might set <code>profilePicture = null</code> to indicate the absence is intentional.
        </p>

        <h4>6. Symbol (ES6)</h4>
        <p>Symbols are JavaScript's newest primitive type, introduced in ES6 (2015). They're unique identifiers that
            are guaranteed to be different from every other Symbol, even if they have the same description. This
            uniqueness makes them perfect for creating object properties that won't conflict with other properties.</p>

        <pre><code class="language-javascript">let id1 = Symbol("id");
let id2 = Symbol("id");

console.log(id1 === id2); // false (each is unique)</code></pre>

        <p>Even though both Symbols have the same description (<code>"id"</code>), they're completely different values.
            This is useful when you need to add properties to objects without risking name collisions, especially in
            libraries or frameworks where you don't control all the code.</p>

        <p>Symbols are also used internally by JavaScript for special behaviors. For example,
            <code>Symbol.iterator</code>
            defines how an object should be iterated, and <code>Symbol.toStringTag</code> customizes how an object is
            converted to a string. While you won't use Symbols every day, they're powerful tools for advanced JavaScript
            patterns.
        </p>

        <h4>7. BigInt (ES2020)</h4>
        <p>JavaScript's Number type can safely represent integers up to 2^53 - 1 (about 9 quadrillion). Beyond that,
            you lose precision. For most applications, this is plenty, but what if you need to work with larger numbers?
            Cryptography, scientific computing, and financial systems sometimes require arbitrary-precision integers.
        </p>

        <p>That's where BigInt comes in. Introduced in ES2020, BigInt can represent integers of arbitrary size, limited
            only by available memory. You create a BigInt by appending <code>n</code> to a number literal or using the
            <code>BigInt()</code> constructor.
        </p>

        <pre><code class="language-javascript">let bigNum = 9007199254740991n;
let huge = BigInt("999999999999999999");

// Can't mix with regular numbers
// console.log(100n + 50); // TypeError
console.log(100n + 50n);   // 150n</code></pre>

        <p>One important limitation: you can't mix BigInt and Number in arithmetic operations. JavaScript won't
            automatically convert between them because the conversion could lose precision. If you need to combine them,
            explicitly convert one type to the other, being mindful of potential precision loss.</p>

        <p>BigInt is relatively new, so check browser compatibility if you're targeting older environments. However,
            for modern applications dealing with large integers, it's an essential tool.</p>

        <h3>Objects: Everything Else</h3>
        <p>Now that we've covered the seven primitive types, let's talk about everything else in JavaScript: objects.
            In JavaScript's type system, if something isn't a primitive, it's an object. This includes plain objects,
            arrays, functions, dates, regular expressions, and more. They're all built on the same fundamental object
            structure.</p>

        <p>This might seem confusing at first - how can an array and a function both be "objects"? The answer lies in
            JavaScript's prototype-based inheritance system. All these types share common object behaviors (like having
            properties and methods), but each adds its own specialized functionality on top of that foundation.</p>

        <pre><code class="language-javascript">let person = { name: "Alice", age: 25 };
let numbers = [1, 2, 3, 4, 5];
let greet = function() { console.log("Hi!"); };

console.log(typeof person);  // "object"
console.log(typeof numbers); // "object"
console.log(typeof greet);   // "function"</code></pre>

        <p>Notice that <code>typeof</code> returns <code>"function"</code> for functions, even though functions are
            technically objects. This is a special case that makes it easier to distinguish functions from other
            objects.
            However, functions still have all the capabilities of objects - you can add properties to them, pass them
            around, and even call methods on them.</p>

        <h3>The Critical Difference: Value vs Reference</h3>
        <p>Understanding the difference between value and reference is perhaps the most important concept for avoiding
            bugs in JavaScript. This is where primitives and objects behave completely differently, and misunderstanding
            this distinction causes more bugs than almost any other JavaScript feature.</p>

        <p><strong>Primitives are copied by value.</strong> When you assign a primitive to a new variable, JavaScript
            creates a completely independent copy of that value. Changes to one variable don't affect the other because
            they're separate values in memory:</p>

        <pre><code class="language-javascript">let a = 5;
let b = a;  // Copy the value
b = 10;

console.log(a); // 5 (unchanged)
console.log(b); // 10</code></pre>

        <p>This behavior is intuitive and matches how we think about numbers and text in the real world. If I write
            the number 5 on two pieces of paper, changing one doesn't affect the other.</p>

        <p><strong>Objects are copied by reference.</strong> When you assign an object to a new variable, JavaScript
            doesn't create a new object - it creates a new reference pointing to the same object in memory. Both
            variables
            now refer to the exact same object, so changes through one variable are visible through the other:</p>

        <pre><code class="language-javascript">let obj1 = { name: "Alice" };
let obj2 = obj1;  // Copy the reference
obj2.name = "Bob";

console.log(obj1.name); // "Bob" (changed!)
console.log(obj2.name); // "Bob"</code></pre>

        <p>This is the source of countless bugs, especially for developers coming from other languages. You might think
            you're creating a backup of an object before modifying it, but you're actually just creating another
            reference
            to the same object. When you modify the "backup," you're modifying the original too.</p>

        <p>This behavior exists for good reasons: objects can be large and complex, so copying them by value would be
            expensive. References are lightweight - they're just pointers to memory locations. However, when you do need
            an independent copy of an object, you need to explicitly clone it.</p>

        <p><strong>Cloning objects</strong> comes in two flavors: shallow and deep. A shallow clone creates a new object
            with copies of the top-level properties, but nested objects are still references. A deep clone recursively
            copies everything, creating a completely independent structure:</p>

        <pre><code class="language-javascript">// Shallow clone
let clone = { ...original };
let clone = Object.assign({}, original);

// Deep clone (simple objects)
let deepClone = JSON.parse(JSON.stringify(original));

// Deep clone (modern way - ES2022)
let deepClone = structuredClone(original);</code></pre>

        <p>The spread operator (<code>...</code>) and <code>Object.assign()</code> create shallow clones - fast and
            sufficient for simple objects. The JSON approach works for deep cloning but has limitations: it can't handle
            functions, undefined values, Symbols, or circular references.</p>

        <p><code>structuredClone()</code> is the modern solution, introduced in ES2022. It handles most JavaScript types
            correctly (including Date, Map, Set, ArrayBuffer, and more) and properly deals with circular references.
            However, it can't clone functions or DOM nodes. For most use cases, it's the best choice for deep cloning.
        </p>

        <h3>Type Checking: typeof and Beyond</h3>
        <p>JavaScript provides the <code>typeof</code> operator to check a value's type at runtime. While useful, it has
            some quirks and limitations you need to be aware of. Understanding these limitations helps you write more
            robust type-checking code.</p>

        <pre><code class="language-javascript">console.log(typeof 42);        // "number"
console.log(typeof "hello");   // "string"
console.log(typeof true);      // "boolean"
console.log(typeof undefined); // "undefined"
console.log(typeof null);      // "object" (bug!)
console.log(typeof {});        // "object"
console.log(typeof []);        // "object" (not helpful!)</code></pre>

        <p>The <code>typeof null</code> returning <code>"object"</code> is a famous JavaScript bug that can't be fixed
            without breaking existing code. More problematically, <code>typeof</code> returns <code>"object"</code> for
            arrays, which doesn't help you distinguish them from plain objects.</p>

        <p>For arrays specifically, use <code>Array.isArray()</code>, which was added to JavaScript specifically to
            solve this problem:</p>

        <pre><code class="language-javascript">Array.isArray([]);  // true
Array.isArray({});  // false</code></pre>

        <p>For more sophisticated type checking, you can use <code>instanceof</code> to check if an object was created
            by a specific constructor, or check the <code>constructor</code> property. However, these approaches have
            their own edge cases, especially when dealing with objects from different JavaScript contexts (like
            iframes).</p>

        <h3>Type Coercion: JavaScript's "Helpful" Feature</h3>
        <p>Type coercion is one of JavaScript's most controversial features. The language automatically converts values
            from one type to another in certain situations, trying to be "helpful" by making your code work even when
            types don't match. This can lead to code that works but produces unexpected results.</p>

        <p>Understanding coercion rules is essential because they affect how operators work, how comparisons behave, and
            how values are converted in conditional statements. Let's explore the main coercion scenarios:</p>

        <pre><code class="language-javascript">// String coercion
console.log("5" + 3);      // "53" (number to string)
console.log("Hello" + 1);  // "Hello1"

// Number coercion
console.log("5" - 2);      // 3 (string to number)
console.log("10" * "2");   // 20
console.log(true + 1);     // 2 (true becomes 1)

// Boolean coercion
console.log(!!"hello");    // true
console.log(!!0);          // false</code></pre>

        <p>Notice the asymmetry: the <code>+</code> operator prefers strings (converting numbers to strings), while
            <code>-</code>, <code>*</code>, and <code>/</code> prefer numbers (converting strings to numbers). This is
            because <code>+</code> serves double duty as both addition and string concatenation. When JavaScript sees
            <code>+</code> with a string, it assumes you want concatenation.
        </p>

        <p>The double-not (<code>!!</code>) is a common idiom for explicitly converting any value to its Boolean
            equivalent. The first <code>!</code> converts to Boolean and negates it, the second <code>!</code> negates
            it back, leaving you with the Boolean representation of the original value.</p>

        <p><strong>Equality coercion</strong> is particularly tricky. JavaScript has two equality operators: loose
            equality (<code>==</code>) which performs type coercion, and strict equality (<code>===</code>) which
            doesn't:</p>

        <pre><code class="language-javascript">// Loose equality (==) coerces types
console.log(5 == "5");     // true
console.log(true == 1);    // true
console.log(null == undefined); // true

// Strict equality (===) doesn't
console.log(5 === "5");    // false
console.log(true === 1);   // false

// Always use === for clarity!</code></pre>

        <p>The coercion rules for <code>==</code> are complex and sometimes counterintuitive. For example,
            <code>[] == ![]</code> is <code>true</code> due to a chain of coercions. To avoid these surprises, the
            JavaScript community has largely standardized on using <code>===</code> (strict equality) by default.
        </p>

        <p>Strict equality checks both value and type, making comparisons predictable and explicit. The only time you
            might use <code>==</code> is when checking for <code>null</code> or <code>undefined</code> simultaneously:
            <code>value == null</code> is true for both <code>null</code> and <code>undefined</code>, which is
            occasionally useful.
        </p>

        <h3>Key Takeaways</h3>
        <ul>
            <li><strong>Primitives</strong> are immutable and copied by value</li>
            <li><strong>Objects</strong> are mutable and copied by reference</li>
            <li>Use <code>===</code> to avoid type coercion surprises</li>
            <li>Check types explicitly when it matters</li>
            <li>Know your falsy values</li>
            <li>Use <code>structuredClone()</code> for deep cloning (ES2022)</li>
        </ul>
    </div>



    <!-- Chapter 2 -->
    <div id="chapter2" class="page-break">
        <h1>Chapter 2: JavaScript Variables and Scope</h1>
        <h2>Master var, let, and const</h2>

        <p>Variables and scope are fundamental to JavaScript, yet they're often misunderstood. The way you declare
            variables affects where they can be accessed, how they behave, and whether they can be reassigned.</p>

        <h3>The Three Ways to Declare Variables</h3>
        <p>JavaScript has three keywords for declaring variables: <code>var</code>, <code>let</code>, and
            <code>const</code>.
        </p>

        <p><strong>var - The Old Way</strong></p>
        <pre><code class="language-javascript">var name = 'Alice';

// var can be redeclared
var name = 'Bob'; // No error!

// var is function-scoped, not block-scoped
if (true) {
    var message = 'Hello';
}
console.log(message); // 'Hello' - accessible outside!</code></pre>

        <p><strong>let - Block-Scoped Variables</strong></p>
        <pre><code class="language-javascript">let name = 'Alice';

// let cannot be redeclared
// let name = 'Bob'; // SyntaxError!

// let is block-scoped
if (true) {
    let message = 'Hello';
}
// console.log(message); // ReferenceError

// But let can be reassigned
let age = 30;
age = 31; // This works</code></pre>

        <p><strong>const - Constants</strong></p>
        <pre><code class="language-javascript">const PI = 3.14159;

// const cannot be reassigned
// PI = 3.14; // TypeError!

// But const objects can be mutated
const person = { name: 'Alice' };
person.name = 'Bob'; // This works!</code></pre>

        <h3>Function Scope vs Block Scope</h3>
        <p><strong>Function Scope (var):</strong></p>
        <pre><code class="language-javascript">function example() {
    var x = 1;
    
    if (true) {
        var x = 2; // Same variable!
        console.log(x); // 2
    }
    
    console.log(x); // 2
}</code></pre>

        <p><strong>Block Scope (let and const):</strong></p>
        <pre><code class="language-javascript">function example() {
    let x = 1;
    
    if (true) {
        let x = 2; // Different variable!
        console.log(x); // 2
    }
    
    console.log(x); // 1
}</code></pre>

        <p>This is crucial in loops:</p>
        <pre><code class="language-javascript">// With var
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
}
// Prints: 3, 3, 3

// With let
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
}
// Prints: 0, 1, 2</code></pre>

        <h3>Lexical Scope and the Scope Chain</h3>
        <p>JavaScript uses lexical scoping - inner functions can access variables from outer scopes:</p>
        <pre><code class="language-javascript">const globalVar = 'global';

function outer() {
    const outerVar = 'outer';
    
    function inner() {
        const innerVar = 'inner';
        console.log(globalVar); // 'global'
        console.log(outerVar);  // 'outer'
        console.log(innerVar);  // 'inner'
    }
    
    inner();
}</code></pre>

        <h3>The Temporal Dead Zone</h3>
        <p>Variables declared with <code>let</code> and <code>const</code> are in a "temporal dead zone" from the start
            of the block until the declaration:</p>
        <pre><code class="language-javascript">// With var - hoisted and initialized
console.log(varVariable); // undefined
var varVariable = 'var';

// With let - hoisted but NOT initialized
// console.log(letVariable); // ReferenceError!
let letVariable = 'let';</code></pre>

        <h3>Best Practices</h3>
        <ol>
            <li><strong>Prefer const by default</strong> - Use for values that won't be reassigned</li>
            <li><strong>Use let when you need to reassign</strong> - For counters, accumulators, etc.</li>
            <li><strong>Avoid var</strong> - No benefits over let/const in modern JavaScript</li>
            <li><strong>Minimize scope</strong> - Declare variables close to where they're used</li>
            <li><strong>Use descriptive names</strong> - Make your code self-documenting</li>
        </ol>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Use const by default, let when you need to reassign, avoid var</li>
            <li>var is function-scoped, let and const are block-scoped</li>
            <li>Lexical scope means inner functions can access outer variables</li>
            <li>The scope chain is searched from inner to outer scopes</li>
            <li>Temporal Dead Zone prevents accessing let/const before declaration</li>
            <li>const prevents reassignment, not mutation</li>
        </ul>
    </div>



    <!-- Chapter 3 -->
    <div id="chapter3" class="page-break">
        <h1>Chapter 3: JavaScript Functions</h1>
        <h2>Master the Building Blocks</h2>

        <p>Functions are the fundamental building blocks of JavaScript. They allow you to encapsulate code, make it
            reusable, and organize your programs into logical units.</p>

        <h3>Function Declarations vs Expressions</h3>
        <p><strong>Function Declarations:</strong></p>
        <pre><code class="language-javascript">function add(a, b) {
    return a + b;
}

// Can be called before definition (hoisted)
sayHello(); // Works!

function sayHello() {
    console.log('Hello!');
}</code></pre>

        <p><strong>Function Expressions:</strong></p>
        <pre><code class="language-javascript">const multiply = function(a, b) {
    return a * b;
};

// Cannot be called before definition
// subtract(); // Error!
const subtract = function(a, b) {
    return a - b;
};</code></pre>

        <h3>Arrow Functions</h3>
        <p>Arrow functions provide concise syntax:</p>
        <pre><code class="language-javascript">// Traditional
const square1 = function(x) {
    return x * x;
};

// Arrow - concise (implicit return)
const square2 = x => x * x;

// Multiple parameters
const add = (a, b) => a + b;

// No parameters
const random = () => Math.random();

// Returning objects
const makePerson = (name, age) => ({ name, age });</code></pre>

        <h3>Parameters and Arguments</h3>
        <p><strong>Default Parameters:</strong></p>
        <pre><code class="language-javascript">function greet(name = 'Guest', greeting = 'Hello') {
    console.log(`${greeting}, ${name}!`);
}

greet(); // Hello, Guest!
greet('Alice'); // Hello, Alice!</code></pre>

        <p><strong>Rest Parameters:</strong></p>
        <pre><code class="language-javascript">function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3)); // 6
console.log(sum(1, 2, 3, 4, 5)); // 15</code></pre>

        <h3>Higher-Order Functions</h3>
        <p>Functions that take or return other functions:</p>
        <pre><code class="language-javascript">// Takes a function
function repeat(n, action) {
    for (let i = 0; i < n; i++) {
        action(i);
    }
}

repeat(3, console.log); // 0, 1, 2

// Returns a function
function multiplyBy(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = multiplyBy(2);
console.log(double(5)); // 10</code></pre>

        <h3>Callback Functions</h3>
        <pre><code class="language-javascript">const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
const sum = numbers.reduce((total, n) => total + n, 0);</code></pre>

        <h3>IIFEs (Immediately Invoked Function Expressions)</h3>
        <pre><code class="language-javascript">(function() {
    console.log('Runs immediately!');
})();

// Creating private scope
const counter = (function() {
    let count = 0;
    
    return {
        increment() {
            count++;
            return count;
        },
        getCount() {
            return count;
        }
    };
})();</code></pre>

        <h3>Best Practices</h3>
        <ol>
            <li><strong>Use descriptive names</strong> - Make function purpose clear</li>
            <li><strong>Keep functions small</strong> - Single responsibility</li>
            <li><strong>Prefer arrow functions for callbacks</strong> - More concise</li>
            <li><strong>Use default parameters</strong> - Instead of checking undefined</li>
            <li><strong>Return early</strong> - Reduce nesting</li>
        </ol>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Function declarations are hoisted, expressions are not</li>
            <li>Arrow functions provide concise syntax and lexical <code>this</code></li>
            <li>Default parameters provide fallback values</li>
            <li>Rest parameters collect remaining arguments</li>
            <li>Higher-order functions take or return functions</li>
            <li>Callbacks are functions passed to be executed later</li>
            <li>IIFEs execute immediately and create private scope</li>
        </ul>
    </div>



    <!-- Chapter 4 -->
    <div id="chapter4" class="page-break">
        <h1>Chapter 4: JavaScript Hoisting</h1>
        <h2>Stop Getting Surprised by Your Code</h2>

        <p>Ever written code that worked in a way you didn't expect? Chances are, hoisting was the culprit. Hoisting
            is one of JavaScript's most misunderstood features, and it's responsible for countless "Wait, why did that
            happen?" moments. The good news is that once you understand how it works, hoisting becomes predictable and
            even useful.</p>

        <p>The confusion around hoisting stems from JavaScript's two-phase execution model. Your code doesn't run
            exactly as written - JavaScript first scans through your code to set up the environment, then executes it.
            This preprocessing step is where hoisting happens, and understanding it is key to avoiding bugs and writing
            more reliable code.</p>

        <h3>What is Hoisting?</h3>
        <p>Hoisting is JavaScript's default behavior of moving declarations to the top of their scope before code
            execution. The term "hoisting" is a metaphor - your code isn't actually rearranged in memory. Instead,
            during the creation phase, JavaScript records all variable and function declarations, making them available
            throughout their scope even before the line where they're declared.</p>

        <p>This means you can sometimes use variables and functions before you declare them, which seems to violate
            the normal top-to-bottom execution flow:</p>

        <pre><code class="language-javascript">console.log(greeting); // undefined (not an error!)
var greeting = "Hello";

sayHi(); // "Hi!" (works perfectly)
function sayHi() {
    console.log("Hi!");
}</code></pre>

        <p>Wait, what? How can we log <code>greeting</code> before it's declared, and call <code>sayHi()</code> before
            it's defined? The answer lies in how JavaScript processes your code.</p>

        <h3>Behind the Scenes</h3>
        <p>JavaScript's execution model has two distinct phases, and understanding this is crucial to understanding
            hoisting:</p>

        <ol>
            <li><strong>Creation phase (compilation)</strong> - JavaScript scans your code, creates the execution
                context,
                and records all declarations. This is when hoisting happens.</li>
            <li><strong>Execution phase</strong> - JavaScript runs your code line by line, executing statements and
                expressions.</li>
        </ol>

        <p>During the creation phase, JavaScript finds all <code>var</code>, <code>let</code>, <code>const</code>, and
            function declarations and registers them in the current scope. However, it treats them differently based on
            how they're declared.</p>

        <pre><code class="language-javascript">// What you write:
console.log(x);
var x = 5;

// What JavaScript does:
var x;              // Hoisted to the top
console.log(x);     // undefined
x = 5;              // Assignment stays in place</code></pre>

        <p>The key insight is that only the <em>declaration</em> is hoisted, not the <em>initialization</em>. The
            variable <code>x</code> is declared at the top of the scope, but the assignment <code>x = 5</code> stays
            where you wrote it. This is why <code>console.log(x)</code> outputs <code>undefined</code> rather than
            throwing an error - the variable exists, it just hasn't been assigned a value yet.</p>

        <h3>The var Problem</h3>
        <p>Variables declared with <code>var</code> are hoisted and automatically initialized to <code>undefined</code>.
            While this might seem convenient, it's actually the source of many subtle bugs. The problem is that
            <code>var</code> makes it too easy to accidentally use a variable before you've given it a meaningful value,
            and JavaScript won't warn you about it.
        </p>

        <p>Consider this classic example that confuses many developers:</p>

        <pre><code class="language-javascript">var name = "Global";

function test() {
    console.log(name); // undefined (not "Global"!)
    var name = "Local";
    console.log(name); // "Local"
}</code></pre>

        <p>Why does the first <code>console.log</code> output <code>undefined</code> instead of <code>"Global"</code>?
            Because the local <code>var name</code> declaration is hoisted to the top of the function scope, creating a
            local variable that shadows the global one. However, the assignment <code>name = "Local"</code> stays where
            it is, so at the point of the first log, the local <code>name</code> exists but is still
            <code>undefined</code>.
        </p>

        <p>This behavior is called "variable shadowing," and it's particularly dangerous because the code looks like it
            should work. You might expect to access the global variable until you declare the local one, but JavaScript
            doesn't work that way. The local declaration affects the entire function scope, even the lines before the
            declaration appears.</p>

        <p>This is why <code>var</code> is considered problematic in modern JavaScript. It's too forgiving - it lets
            you write code that runs without errors but doesn't do what you expect.</p>

        <h3>Enter let and const: The Temporal Dead Zone</h3>
        <p>ES6 (2015) introduced <code>let</code> and <code>const</code> to address the problems with <code>var</code>.
            These new declaration keywords are also hoisted, but they behave differently in a crucial way: they're
            <strong>not initialized</strong> until the line where they're declared is executed.
        </p>

        <p>This creates what's called the "Temporal Dead Zone" (TDZ) - a period where the variable exists in scope but
            cannot be accessed. If you try to use the variable during this period, JavaScript throws a ReferenceError:
        </p>

        <pre><code class="language-javascript">console.log(x); // ReferenceError!
let x = 5;</code></pre>

        <p>The Temporal Dead Zone starts at the beginning of the scope and ends when the declaration is reached. During
            this time, the variable is in a kind of limbo - it's been hoisted and registered in the scope, but it's not
            yet initialized and cannot be accessed:</p>

        <pre><code class="language-javascript">function example() {
    // TDZ starts for 'temp'
    console.log(temp); // ReferenceError
    
    let temp = 5;      // TDZ ends
    console.log(temp); // 5
}</code></pre>

        <p>At first glance, the TDZ might seem like an annoyance - why not just initialize <code>let</code> and
            <code>const</code> to <code>undefined</code> like <code>var</code>? The answer is that the TDZ is actually
            a feature, not a bug. It catches a whole class of errors at runtime that would otherwise silently produce
            incorrect results.
        </p>

        <p>By throwing an error when you try to access a variable before it's declared, JavaScript forces you to write
            code in a more logical order. This makes your code easier to understand and less prone to subtle bugs. The
            TDZ is strict, but that strictness helps you write better code.</p>

        <h3>Function Hoisting: The Full Story</h3>
        <p>Functions in JavaScript can be declared in two main ways: function declarations and function expressions. The
            way you declare a function dramatically affects how it's hoisted, and understanding this difference is
            crucial
            for avoiding bugs.</p>

        <p><strong>Function declarations</strong> are fully hoisted - both the name and the entire function body. This
            means you can call a function before it appears in your code:</p>

        <pre><code class="language-javascript">greet(); // Works!

function greet() {
    console.log("Hello!");
}</code></pre>

        <p>This behavior is actually quite useful. It allows you to organize your code with the high-level logic at the
            top and helper functions at the bottom, making your code more readable. The function is available throughout
            its entire scope, regardless of where it's declared.</p>

        <p><strong>Function expressions</strong>, however, follow variable hoisting rules. When you assign a function to
            a variable, only the variable declaration is hoisted, not the function itself:</p>

        <pre><code class="language-javascript">sayHi(); // TypeError: sayHi is not a function

var sayHi = function() {
    console.log("Hi!");
};</code></pre>

        <p>Why does this throw a TypeError rather than a ReferenceError? Because <code>var sayHi</code> is hoisted and
            initialized to <code>undefined</code>. When JavaScript tries to execute <code>sayHi()</code>, it's actually
            trying to call <code>undefined()</code>, which is a type error - <code>undefined</code> is not a function.
        </p>

        <p>If you use <code>const</code> or <code>let</code> for a function expression, you'll get a ReferenceError
            instead due to the Temporal Dead Zone:</p>

        <pre><code class="language-javascript">greet(); // ReferenceError: Cannot access 'greet' before initialization

const greet = function() {
    console.log("Hello!");
};</code></pre>

        <p>This is actually better because the error message is clearer about what went wrong. The lesson here is that
            if you need to call a function before it's defined, use a function declaration. If you're using function
            expressions, make sure to define them before you use them.</p>

        <h3>Real-World Gotcha: Loop Variables</h3>
        <p>One of the most common and confusing hoisting-related bugs involves loop variables and asynchronous code.
            This example has confused countless developers, and understanding why it happens requires combining your
            knowledge of hoisting, scope, and closures:</p>

        <pre><code class="language-javascript">// With var
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
}
// Prints: 3, 3, 3

// With let
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
}
// Prints: 0, 1, 2</code></pre>

        <p>Why does the <code>var</code> version print <code>3, 3, 3</code> instead of <code>0, 1, 2</code>? The answer
            involves both hoisting and scope. With <code>var</code>, the variable <code>i</code> is hoisted to function
            scope (or global scope if not in a function), so there's only one <code>i</code> variable shared by all
            three setTimeout callbacks.</p>

        <p>By the time the setTimeout callbacks execute (after 100ms), the loop has finished running and <code>i</code>
            has the value 3. All three callbacks reference the same <code>i</code>, so they all log 3.</p>

        <p>With <code>let</code>, each iteration of the loop gets its own block-scoped <code>i</code>. JavaScript
            creates a new binding for <code>i</code> in each iteration, so each setTimeout callback captures its own
            separate <code>i</code>. This is exactly what you want in most cases.</p>

        <p>This example perfectly illustrates why <code>let</code> and <code>const</code> are preferred over
            <code>var</code> in modern JavaScript. The block scoping behavior is more intuitive and matches what most
            developers expect.
        </p>

        <h3>Best Practices</h3>
        <ol>
            <li><strong>Use const and let, Never var</strong></li>
            <li><strong>Declare Variables at the Top</strong></li>
            <li><strong>Declare Functions Before Use</strong></li>
            <li><strong>Enable Strict Mode</strong></li>
        </ol>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Hoisting moves declarations to the top of their scope</li>
            <li><code>var</code> is hoisted and initialized to <code>undefined</code></li>
            <li><code>let</code> and <code>const</code> are hoisted but not initialized (TDZ)</li>
            <li>Function declarations are fully hoisted</li>
            <li>Function expressions follow variable rules</li>
            <li>Modern JavaScript with <code>let</code> and <code>const</code> makes hoisting less problematic</li>
        </ul>
    </div>


    <!-- PART II -->
    <div class="page-break">
        <h1 class="center">Part II</h1>
        <h2 class="center">Advanced Functions</h2>
    </div>

    <!-- Chapter 5 -->
    <div id="chapter5" class="page-break">
        <h1>Chapter 5: JavaScript Closures</h1>
        <h2>The Secret Weapon You're Already Using</h2>

        <p>If you've written JavaScript for more than a day, you've used closures - even if you didn't know it. Closures
            are one of JavaScript's most powerful features, yet they're often misunderstood or overlooked. They're the
            mechanism behind many common JavaScript patterns, from event handlers to React hooks to module patterns.</p>

        <p>The beauty of closures is that they're not some advanced feature you need to explicitly invoke - they happen
            automatically whenever you create a function inside another function. Understanding closures transforms you
            from someone who writes JavaScript that works to someone who understands why it works and can leverage this
            understanding to write more elegant, powerful code.</p>

        <h3>What is a Closure?</h3>
        <p>A closure is a function that has access to variables from its outer (enclosing) scope, even after the outer
            function has finished executing. This might sound abstract, so let's break it down with a concrete example:
        </p>

        <pre><code class="language-javascript">function outer() {
    let count = 0;
    
    function inner() {
        count++;
        console.log(count);
    }
    
    return inner;
}

const counter = outer();
counter(); // 1
counter(); // 2
counter(); // 3</code></pre>

        <p>What's happening here is remarkable when you think about it. The <code>outer()</code> function executes and
            returns, which normally means all its local variables would be garbage collected and disappear. But the
            <code>count</code> variable doesn't disappear - it stays alive because the <code>inner</code> function still
            references it.
        </p>

        <p>The <code>inner</code> function "closes over" the <code>count</code> variable, creating a closure. This
            closure
            is a combination of the function and the lexical environment (the variables) in which it was declared. Every
            time you call <code>counter()</code>, it accesses and modifies the same <code>count</code> variable, even
            though <code>outer()</code> finished executing long ago.</p>

        <p>This is possible because JavaScript functions are first-class objects - they can be passed around, returned
            from other functions, and they carry their scope with them. The closure keeps the variables alive as long as
            the function that references them exists.</p>

        <h3>Why Closures Matter</h3>
        <p>Closures aren't just a theoretical concept - they're a practical tool that solves real problems in JavaScript
            development. Let's explore the three main use cases where closures shine.</p>

        <h4>1. Data Privacy</h4>
        <p>JavaScript doesn't have traditional private variables like some other languages. Before ES2022's private
            fields,
            closures were the primary way to create truly private data. Even now, closures remain a powerful
            encapsulation
            technique.</p>

        <p>Consider a bank account where you want to prevent direct manipulation of the balance. Closures let you create
            private variables that can only be accessed through specific methods:</p>

        <pre><code class="language-javascript">function createBankAccount(initialBalance) {
    let balance = initialBalance;
    
    return {
        deposit(amount) {
            balance += amount;
            return balance;
        },
        withdraw(amount) {
            if (amount <= balance) {
                balance -= amount;
                return balance;
            }
            return "Insufficient funds";
        },
        getBalance() {
            return balance;
        }
    };
}

const account = createBankAccount(100);
account.deposit(50);    // 150
account.withdraw(30);   // 120
// Can't access balance directly!</code></pre>

        <p>The <code>balance</code> variable is completely private - there's no way to access or modify it except
            through
            the methods we've provided. This is true encapsulation: the internal state is hidden, and the only way to
            interact with it is through a controlled interface. You can't accidentally set <code>balance</code> to a
            negative number or a string - the only way to change it is through <code>deposit()</code> and
            <code>withdraw()</code>, which can enforce business rules.
        </p>

        <h4>2. Function Factories</h4>
        <p>Closures enable a powerful pattern called "function factories" - functions that create and return other
            functions
            with specific behaviors baked in. This is particularly useful when you need multiple similar functions with
            different configurations.</p>

        <pre><code class="language-javascript">function multiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15</code></pre>

        <p>Each call to <code>multiplier()</code> creates a new closure with its own <code>factor</code> variable.
            <code>double</code> and <code>triple</code> are independent functions, each remembering their own factor.
            This pattern eliminates code duplication - instead of writing separate <code>double()</code> and
            <code>triple()</code> functions, we generate them from a single factory.
        </p>

        <p>Function factories are everywhere in modern JavaScript. React's custom hooks, Redux's action creators, and
            many utility libraries use this pattern to create specialized functions on demand.</p>

        <h4>3. Event Handlers</h4>
        <p>Event handlers are one of the most common places where closures appear, often without developers realizing
            it.
            When you attach an event listener, the callback function forms a closure over any variables in its scope:
        </p>

        <pre><code class="language-javascript">function setupButton(buttonId) {
    let clickCount = 0;
    
    document.getElementById(buttonId).addEventListener('click', function() {
        clickCount++;
        console.log(`Button clicked ${clickCount} times`);
    });
}</code></pre>

        <p>The event handler function closes over <code>clickCount</code>, maintaining its own counter that persists
            between clicks. Each button you set up with <code>setupButton()</code> gets its own independent counter -
            they don't interfere with each other because each has its own closure.</p>

        <p>This pattern is incredibly useful for maintaining state in event-driven code without resorting to global
            variables or complex state management systems.</p>

        <h3>Common Pitfall: Loop Closures</h3>
        <p>One of the most confusing aspects of closures for beginners is how they interact with loops. This classic
            problem has tripped up countless developers and demonstrates an important subtlety about how closures work:
        </p>

        <pre><code class="language-javascript">// Problem
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i);
    }, 100);
}
// Prints: 3, 3, 3

// Solution 1: Use let
for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i);
    }, 100);
}
// Prints: 0, 1, 2

// Solution 2: IIFE
for (var i = 0; i < 3; i++) {
    (function(j) {
        setTimeout(function() {
            console.log(j);
        }, 100);
    })(i);
}
// Prints: 0, 1, 2</code></pre>

        <p>The problem occurs because all three setTimeout callbacks close over the same <code>i</code> variable. By the
            time the callbacks execute (after 100ms), the loop has finished and <code>i</code> is 3. All three closures
            reference the same variable, so they all see the final value.</p>

        <p>The <code>let</code> solution works because <code>let</code> creates a new binding for each iteration of the
            loop. Each setTimeout callback closes over its own separate <code>i</code>, capturing the value from that
            specific iteration.</p>

        <p>The IIFE (Immediately Invoked Function Expression) solution works by creating a new scope for each iteration.
            The IIFE takes <code>i</code> as a parameter (renamed to <code>j</code> for clarity), creating a new
            variable
            that captures the current value. This was the common solution before <code>let</code> was introduced.</p>

        <p>This pitfall illustrates an important principle: closures capture variables by reference, not by value. They
            don't take a snapshot of the variable's value - they maintain a live connection to the variable itself.</p>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Closures give functions access to their outer scope</li>
            <li>They enable data privacy and encapsulation</li>
            <li>Perfect for creating function factories</li>
            <li>Essential for event handlers and callbacks</li>
            <li>Closures capture variables by reference, not by value</li>
            <li>Use <code>let</code> in loops to avoid closure pitfalls</li>
        </ul>
    </div>



    <!-- Chapter 7 -->
    <div id="chapter6" class="page-break">
        <h1>Chapter 6: JavaScript 'this' Keyword</h1>
        <h2>The Keyword That Confuses Everyone</h2>

        <p>If you've ever written <code>console.log(this)</code> and been surprised by what you saw, you're not alone.
            The <code>this</code> keyword is JavaScript's most misunderstood feature, responsible for more "Wait, why
            doesn't this work?" moments than perhaps any other aspect of the language. The confusion stems from the fact
            that <code>this</code> behaves differently in JavaScript than in most other programming languages.</p>

        <p>In languages like Java or C++, <code>this</code> always refers to the instance of the class where the method
            is defined. It's predictable and static. JavaScript's <code>this</code>, however, is dynamic - its value is
            determined at runtime based on how a function is called, not where it's defined. This flexibility is
            powerful,
            but it requires understanding the rules that govern <code>this</code> binding.</p>

        <h3>What is 'this'?</h3>
        <p>In JavaScript, <code>this</code> refers to the <strong>context</strong> in which a function is executed. The
            key insight is that <code>this</code> is determined by the <strong>call site</strong> - the location in code
            where the function is called - not by where the function is defined. This dynamic binding is what makes
            <code>this</code> both powerful and confusing.
        </p>

        <p>Let's start with a simple example that seems to work as expected:</p>

        <pre><code class="language-javascript">const person = {
    name: "Alice",
    greet: function() {
        console.log(`Hello, I'm ${this.name}`);
    }
};

person.greet(); // "Hello, I'm Alice"</code></pre>

        <p>Simple enough, right? When you call <code>person.greet()</code>, <code>this</code> refers to
            <code>person</code>, so <code>this.name</code> is <code>"Alice"</code>. This is called "implicit binding" -
            the object to the left of the dot becomes <code>this</code>.
        </p>

        <p>Now watch what happens when we extract the method:</p>

        <pre><code class="language-javascript">const greet = person.greet;
greet(); // "Hello, I'm undefined"</code></pre>

        <p>Wait, what happened? The function lost its context! When you call <code>greet()</code> as a standalone
            function, there's no object to the left of the dot, so <code>this</code> falls back to the global object
            (or <code>undefined</code> in strict mode). This is one of the most common sources of bugs in JavaScript,
            especially when passing methods as callbacks.</p>

        <h3>The Four Rules of 'this'</h3>
        <p>Understanding <code>this</code> comes down to four binding rules. These rules have a priority order - if
            multiple rules apply, the higher-priority rule wins. Master these, and you'll never be confused again.</p>

        <h4>1. Default Binding (Standalone Function)</h4>
        <p>This is the fallback rule when no other binding applies. When you call a function by itself, without any
            context, <code>this</code> refers to the global object (in browsers, that's <code>window</code>). In strict
            mode, it's <code>undefined</code> instead.</p>

        <pre><code class="language-javascript">function showThis() {
    console.log(this);
}

showThis(); // Window (or global object)</code></pre>

        <p>This is the lowest priority rule - it only applies when none of the other rules do.</p>

        <h4>2. Implicit Binding (Method Call)</h4>
        <p>When you call a function as a method of an object (using dot notation), <code>this</code> refers to that
            object. The object "owns" the function call, so it becomes the context.</p>

        <pre><code class="language-javascript">const user = {
    name: "Bob",
    greet() {
        console.log(`Hi, I'm ${this.name}`);
    }
};

user.greet(); // "Hi, I'm Bob"</code></pre>

        <p><strong>The catch:</strong> This binding is easily lost. When you extract a method and call it separately,
            you lose the implicit binding because there's no longer an object to the left of the dot:</p>

        <pre><code class="language-javascript">const greet = user.greet;
greet(); // "Hi, I'm undefined" - lost context!</code></pre>

        <p>This is a common source of bugs, especially when passing methods as callbacks to functions like
            <code>setTimeout</code> or event listeners.
        </p>

        <h4>3. Explicit Binding (call, apply, bind)</h4>
        <p>JavaScript provides three methods that let you explicitly control what <code>this</code> refers to. These
            override implicit binding and give you direct control over the context:</p>

        <pre><code class="language-javascript">function introduce(greeting) {
    console.log(`${greeting}, I'm ${this.name}`);
}

const person = { name: "Alice" };

introduce.call(person, "Hello");  // "Hello, I'm Alice"
introduce.apply(person, ["Hi"]);  // "Hi, I'm Alice"

const boundIntroduce = introduce.bind(person);
boundIntroduce("Hey"); // "Hey, I'm Alice"</code></pre>

        <p><code>call()</code> and <code>apply()</code> immediately invoke the function with the specified
            <code>this</code> value. The only difference is how they handle additional arguments: <code>call()</code>
            takes them individually, while <code>apply()</code> takes them as an array.
        </p>

        <p><code>bind()</code> doesn't invoke the function immediately. Instead, it returns a new function with
            <code>this</code> permanently bound to the specified value. This is useful for creating callback functions
            that maintain their context.
        </p>

        <h4>4. New Binding (Constructor)</h4>
        <p>When you call a function with the <code>new</code> keyword, JavaScript creates a new empty object and sets
            <code>this</code> to refer to that object. This is how constructor functions work:
        </p>

        <pre><code class="language-javascript">function Person(name) {
    this.name = name;
}

const alice = new Person("Alice");
console.log(alice.name); // "Alice"</code></pre>

        <p>The <code>new</code> keyword does four things: creates a new object, sets <code>this</code> to that object,
            executes the constructor function, and returns the object (unless the constructor explicitly returns
            something else). This is the highest priority binding rule.</p>

        <h3>Arrow Functions: The Game Changer</h3>
        <p>Arrow functions introduced in ES6 fundamentally changed how <code>this</code> works. Unlike regular
            functions,
            arrow functions don't have their own <code>this</code> binding. Instead, they inherit <code>this</code> from
            the surrounding lexical scope - the scope where the arrow function was defined.</p>

        <p>This "lexical this" behavior solves one of JavaScript's most annoying problems: losing <code>this</code> in
            callbacks:</p>

        <pre><code class="language-javascript">const counter = {
    count: 0,
    start: function() {
        setInterval(() => {
            this.count++; // 'this' is counter!
            console.log(this.count);
        }, 1000);
    }
};

counter.start(); // 1, 2, 3...</code></pre>

        <p>The arrow function inside <code>setInterval</code> doesn't have its own <code>this</code>, so it uses
            <code>this</code> from the <code>start</code> method, which is <code>counter</code>. This works perfectly.
        </p>

        <p>With a regular function, this breaks because the callback has its own <code>this</code> that's set by how
            <code>setInterval</code> calls it:
        </p>

        <pre><code class="language-javascript">const counter = {
    count: 0,
    start: function() {
        setInterval(function() {
            this.count++; // 'this' is NOT counter!
            console.log(this.count); // NaN
        }, 1000);
    }
};</code></pre>

        <p>Arrow functions can't be used as constructors (you can't use <code>new</code> with them), and you can't
            change their <code>this</code> with <code>call()</code>, <code>apply()</code>, or <code>bind()</code>. Their
            <code>this</code> is permanently set to the lexical scope where they were created.
        </p>

        <h3>Real-World Problem: Event Handlers</h3>
        <p>Event handlers are where <code>this</code> confusion most commonly appears in real applications. When you
            pass
            a method as an event handler, it loses its context:</p>

        <pre><code class="language-javascript">class Button {
    constructor() {
        this.count = 0;
    }
    
    handleClick() {
        this.count++;
        console.log(this.count);
    }
}

const btn = new Button();
element.addEventListener('click', btn.handleClick);
// Click! TypeError: Cannot read property 'count' of undefined</code></pre>

        <p><strong>Why does this fail?</strong> When you pass <code>btn.handleClick</code> to
            <code>addEventListener</code>, you're passing the function itself, not a method call. The event listener
            calls the function later without any context, so <code>this</code> becomes the DOM element (the event
            target),
            not the Button instance.
        </p>

        <p><strong>Three solutions:</strong></p>

        <pre><code class="language-javascript">// Solution 1: Arrow function wrapper
element.addEventListener('click', () => btn.handleClick());

// Solution 2: Bind in constructor
class Button {
    constructor() {
        this.count = 0;
        this.handleClick = this.handleClick.bind(this);
    }
    
    handleClick() {
        this.count++;
        console.log(this.count);
    }
}

// Solution 3: Class field with arrow function
class Button {
    count = 0;
    
    handleClick = () => {
        this.count++;
        console.log(this.count);
    }
}</code></pre>

        <p>Solution 1 creates a new function that calls the method with the correct context. Solution 2 creates a bound
            version of the method that always has the correct <code>this</code>. Solution 3 uses a class field with an
            arrow function, which automatically captures <code>this</code> from the class instance. All three work, but
            Solution 3 is the most modern and concise.</p>

        <h3>Key Takeaways</h3>
        <ul>
            <li><code>this</code> is determined by how a function is called</li>
            <li>Four binding rules: default, implicit, explicit, new</li>
            <li>Arrow functions inherit <code>this</code> from enclosing scope</li>
            <li>Use <code>bind()</code>, <code>call()</code>, or <code>apply()</code> for explicit binding</li>
            <li>Arrow functions solve most callback <code>this</code> problems</li>
            <li>Class fields with arrow functions auto-bind <code>this</code></li>
        </ul>
    </div>


    <!-- Chapter 6 -->
    <div id="chapter6" class="page-break">
        <h1>Chapter 7: JavaScript Currying</h1>
        <h2>Write More Reusable Code</h2>

        <p>Function currying is one of those functional programming concepts that sounds complicated but is surprisingly
            simple once you see it in action. It's a technique that transforms how you think about function composition
            and reusability, enabling elegant solutions to common programming problems.</p>

        <p>While currying comes from functional programming theory, you don't need to understand category theory or
            lambda calculus to use it effectively. In JavaScript, currying is simply a practical tool for creating more
            flexible, reusable functions. Once you understand the pattern, you'll start seeing opportunities to use it
            everywhere.</p>

        <h3>What is Currying?</h3>
        <p>Currying transforms a function that takes multiple arguments into a sequence of functions, each taking a
            single argument. Instead of calling a function with all its arguments at once, you call it with one argument
            at a time, and each call returns a new function that expects the next argument.</p>

        <pre><code class="language-javascript">// Regular function
function add(a, b, c) {
    return a + b + c;
}
add(1, 2, 3); // 6

// Curried version
const addCurried = a => b => c => a + b + c;
addCurried(1)(2)(3); // 6</code></pre>

        <p>Named after mathematician Haskell Curry (though the concept predates him), this technique enables powerful
            patterns for code reuse. The curried version might look strange at first - why would you want to call a
            function three times instead of once? The answer lies in partial application.</p>

        <p>With currying, you can provide arguments incrementally. You might call <code>addCurried(1)</code> and get
            back a function that's "waiting" for the next two arguments. This partially applied function can be passed
            around, stored in variables, or used to create specialized versions of the original function. This
            flexibility
            is what makes currying so powerful.</p>

        <h3>Why Should You Care?</h3>
        <p>Currying isn't just an academic exercise - it solves real problems in JavaScript development. Let's explore
            three practical use cases that demonstrate why currying is worth learning.</p>

        <h4>1. Create Reusable Function Factories</h4>
        <p>One of the most powerful applications of currying is creating specialized functions from general ones.
            Instead
            of writing multiple similar functions, you write one curried function and derive the specialized versions
            from it:</p>

        <pre><code class="language-javascript">const multiply = a => b => a * b;

const double = multiply(2);
const triple = multiply(3);

double(5);  // 10
triple(5);  // 15</code></pre>

        <p>You've just created specialized functions from a general one without any code duplication. No need to write
            separate <code>multiplyByTwo</code> and <code>multiplyByThree</code> functions. This pattern scales
            beautifully - you can create as many specialized multipliers as you need, and they all share the same
            underlying implementation.</p>

        <p>This approach follows the DRY (Don't Repeat Yourself) principle at a higher level. Instead of repeating
            similar function implementations, you're creating a factory that generates the functions you need.</p>

        <h4>2. Cleaner Event Handlers</h4>
        <p>Event handlers often need access to data beyond just the event object. Currying provides an elegant solution
            that's cleaner than traditional approaches:</p>

        <pre><code class="language-javascript">const handleClick = id => event => {
    console.log(`Clicked item ${id}`);
    // Handle the event
};

// Instead of this:
button1.addEventListener('click', (e) => handleClick(1, e));
button2.addEventListener('click', (e) => handleClick(2, e));

// Write this:
button1.addEventListener('click', handleClick(1));
button2.addEventListener('click', handleClick(2));</code></pre>

        <p>The curried version is more concise and reads more naturally. You're "configuring" the handler with the ID,
            then passing the configured handler to addEventListener. This pattern is particularly useful when you have
            many similar event handlers that differ only in their configuration.</p>

        <h4>3. Build Data Pipelines</h4>
        <p>Currying shines when building data transformation pipelines. By currying your transformation functions, you
            can compose them in flexible ways:</p>

        <pre><code class="language-javascript">const map = fn => array => array.map(fn);
const filter = pred => array => array.filter(pred);

const double = x => x * 2;
const isEven = x => x % 2 === 0;

const processNumbers = numbers => 
    filter(isEven)(map(double)(numbers));

processNumbers([1, 2, 3, 4]); // [4, 8]</code></pre>

        <p>This pipeline doubles each number, then filters to keep only even results. The curried <code>map</code> and
            <code>filter</code> functions can be reused in different combinations, creating a library of composable
            transformations. This is the essence of functional programming - building complex operations from simple,
            reusable pieces.
        </p>

        <h3>Real-World Example: API Client</h3>
        <p>Let's see currying in action with a practical example: building a configurable API client. This demonstrates
            how currying enables progressive configuration, where you specify general settings first and specific
            details
            later:</p>

        <pre><code class="language-javascript">const apiRequest = baseURL => endpoint => method => data => {
    return fetch(`${baseURL}${endpoint}`, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: data ? JSON.stringify(data) : undefined
    }).then(r => r.json());
};

// Configure once
const api = apiRequest('https://api.example.com');
const usersAPI = api('/users');

// Reuse everywhere
const getUsers = usersAPI('GET')(null);
const createUser = usersAPI('POST');
const updateUser = usersAPI('PUT');

// Use it
getUsers.then(users => console.log(users));
createUser({ name: 'Alice' }).then(user => console.log(user));</code></pre>

        <p>This pattern creates a hierarchy of increasingly specific functions. First, you configure the base URL, then
            the endpoint, then the HTTP method, and finally the data. Each level can be reused independently. The
            <code>usersAPI</code> function can create GET, POST, PUT, and DELETE operations for the users endpoint,
            all sharing the same base configuration.
        </p>

        <h3>Automatic Currying</h3>
        <p>Writing nested arrow functions for every curried function gets tedious. You can create a helper function that
            automatically curries any function, making currying more practical for everyday use:</p>

        <pre><code class="language-javascript">function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        }
        return (...nextArgs) => curried(...args, ...nextArgs);
    };
}

// Now curry any function
const add = curry((a, b, c) => a + b + c);

add(1)(2)(3);     // 6
add(1, 2)(3);     // 6
add(1)(2, 3);     // 6
add(1, 2, 3);     // 6 - all work!</code></pre>

        <p>This curry helper is flexible - it accepts arguments one at a time, all at once, or any combination. It
            checks
            if enough arguments have been provided (using <code>fn.length</code>, which gives the function's arity), and
            if so, calls the original function. Otherwise, it returns a new function that accumulates more arguments.
        </p>

        <p>This flexibility makes curried functions more practical. You're not forced into the one-argument-at-a-time
            pattern - you can provide multiple arguments when convenient while still getting the benefits of partial
            application.</p>

        <h3>When to Use Currying</h3>
        <p>Currying is a powerful technique, but like any tool, it's not appropriate for every situation. Here's
            guidance
            on when to use it and when to stick with traditional functions:</p>

        <p><strong>Use currying when:</strong></p>
        <ul>
            <li><strong>Building configurable functions</strong> - When you need functions with different configurations
            </li>
            <li><strong>Creating specialized versions</strong> - Deriving specific functions from general ones</li>
            <li><strong>Working with functional composition</strong> - Building pipelines of transformations</li>
            <li><strong>Partial application is frequent</strong> - You often call functions with some but not all
                arguments</li>
        </ul>

        <p><strong>Skip currying when:</strong></p>
        <ul>
            <li><strong>Functions are called once with all arguments</strong> - No benefit from partial application</li>
            <li><strong>Performance is critical</strong> - Currying adds function call overhead (though usually
                negligible)</li>
            <li><strong>Team is unfamiliar with the pattern</strong> - Code readability matters more than cleverness
            </li>
            <li><strong>It doesn't improve readability</strong> - Sometimes traditional functions are clearer</li>
        </ul>

        <p>The key is to use currying where it genuinely improves your code, not just because it's a cool technique.
            When
            currying makes your code more reusable and easier to understand, use it. When it just makes things more
            complex, stick with regular functions.</p>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Currying transforms <code>f(a, b, c)</code> into <code>f(a)(b)(c)</code></li>
            <li>Enables partial application and function reuse</li>
            <li>Perfect for configuration and specialization</li>
            <li>Use arrow functions for clean syntax</li>
            <li>Create a curry helper for convenience</li>
        </ul>
    </div>



    <!-- PART III -->
    <div class="page-break">
        <h1 class="center">Part III</h1>
        <h2 class="center">Object-Oriented JavaScript</h2>
    </div>

    <!-- Chapter 8 -->
    <div id="chapter8" class="page-break">
        <h1>Chapter 8: JavaScript Encapsulation</h1>
        <h2>Master Data Hiding and Private Variables</h2>

        <p>Encapsulation is one of those programming principles that sounds intimidating but is actually quite practical
            once you understand it. If you've ever wanted to protect your data from being accidentally modified or
            create
            cleaner APIs for your code, encapsulation is the answer.</p>

        <h3>What is Encapsulation?</h3>
        <p>Encapsulation is the practice of bundling data and methods together while hiding internal implementation
            details
            from the outside world. It's one of the four fundamental principles of object-oriented programming (along
            with
            inheritance, polymorphism, and abstraction).</p>

        <p>In JavaScript, encapsulation helps you protect data, control access, reduce coupling, and improve
            maintainability.</p>

        <pre><code class="language-javascript">// Without encapsulation - data is exposed
const account = {
    balance: 1000
};
account.balance = -500; // Oops! No validation

// With encapsulation - data is protected
function createAccount(initialBalance) {
    let balance = initialBalance; // Private
    
    return {
        deposit(amount) {
            if (amount > 0) {
                balance += amount;
                return true;
            }
            return false;
        },
        getBalance() {
            return balance;
        }
    };
}

const myAccount = createAccount(1000);
myAccount.deposit(500);
console.log(myAccount.getBalance()); // 1500
myAccount.balance = -500;            // Has no effect!</code></pre>

        <h3>Private Variables with Closures</h3>
        <p>Before ES2022, closures were the primary way to create private variables in JavaScript:</p>

        <pre><code class="language-javascript">function Counter() {
    let count = 0; // Private variable
    
    this.increment = function() {
        count++;
        return count;
    };
    
    this.getCount = function() {
        return count;
    };
}

const counter = new Counter();
counter.increment(); // 1
counter.increment(); // 2
console.log(counter.count); // undefined - private!</code></pre>

        <h3>ES2022 Private Fields</h3>
        <p>Modern JavaScript introduced true private fields using the <code>#</code> prefix:</p>

        <pre><code class="language-javascript">class BankAccount {
    #balance; // Private field
    
    constructor(initialBalance) {
        this.#balance = initialBalance;
    }
    
    deposit(amount) {
        if (amount <= 0) {
            throw new Error('Amount must be positive');
        }
        this.#balance += amount;
        return this.#balance;
    }
    
    getBalance() {
        return this.#balance;
    }
}

const account = new BankAccount(1000);
account.deposit(500);
console.log(account.getBalance()); // 1500
// account.#balance; // SyntaxError!</code></pre>

        <p>Private fields are truly private - attempting to access them from outside the class results in a syntax
            error.
        </p>

        <h3>The Module Pattern</h3>
        <p>The Module Pattern uses an IIFE to create a private scope:</p>

        <pre><code class="language-javascript">const Calculator = (function() {
    // Private
    let history = [];
    
    function log(operation, result) {
        history.push({ operation, result });
    }
    
    // Public API
    return {
        add(a, b) {
            const result = a + b;
            log(`${a} + ${b}`, result);
            return result;
        },
        getHistory() {
            return [...history];
        }
    };
})();

Calculator.add(5, 3); // 8
console.log(Calculator.history); // undefined - private!</code></pre>

        <h3>Getters and Setters</h3>
        <p>Getters and setters provide controlled access with validation:</p>

        <pre><code class="language-javascript">class Temperature {
    #celsius;
    
    get celsius() {
        return this.#celsius;
    }
    
    set celsius(value) {
        if (value < -273.15) {
            throw new Error('Below absolute zero');
        }
        this.#celsius = value;
    }
    
    get fahrenheit() {
        return (this.#celsius * 9/5) + 32;
    }
}

const temp = new Temperature();
temp.celsius = 25;
console.log(temp.fahrenheit); // 77</code></pre>

        <h3>Best Practices</h3>
        <ol>
            <li><strong>Make everything private by default</strong> - Only expose what's necessary</li>
            <li><strong>Use getters for computed properties</strong> - Calculate values on demand</li>
            <li><strong>Validate in setters</strong> - Ensure data integrity</li>
            <li><strong>Return copies, not references</strong> - Prevent external modification</li>
            <li><strong>Use meaningful method names</strong> - Make your API clear</li>
        </ol>

        <h3>When to Use Encapsulation</h3>
        <p><strong>Use it when:</strong></p>
        <ul>
            <li>You need to protect data integrity</li>
            <li>You want to control how data is accessed</li>
            <li>You're building reusable components</li>
            <li>You need validation before changes</li>
        </ul>

        <p><strong>Skip it when:</strong></p>
        <ul>
            <li>You're building simple data structures</li>
            <li>The code is only used internally</li>
            <li>The data doesn't need protection</li>
        </ul>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Encapsulation bundles data and methods while hiding implementation</li>
            <li>Use closures for private variables in functions</li>
            <li>ES2022 private fields (#) are the modern way for classes</li>
            <li>The Module Pattern creates singletons with private state</li>
            <li>Getters and setters provide controlled access</li>
            <li>Always return copies of internal data, not references</li>
            <li>Make everything private by default</li>
            <li>Don't over-encapsulate simple structures</li>
        </ul>
    </div>



    <!-- Chapter 9 -->
    <div id="chapter9" class="page-break">
        <h1>Chapter 9: JavaScript Inheritance</h1>
        <h2>Master Prototypal Inheritance and ES6 Classes</h2>

        <p>Inheritance is one of those concepts that sounds complicated but is actually quite natural once you
            understand
            it. If you've been writing JavaScript for a while, you've probably used inheritance without even realizing
            it.
            Let me show you how it works and why it matters.</p>

        <h3>What is Inheritance?</h3>
        <p>Inheritance is a mechanism that allows one object to acquire properties and methods from another object. It's
            like saying "a Dog is an Animal" - the Dog inherits all the characteristics of an Animal, plus adds its own
            specific behaviors.</p>

        <p>Unlike classical languages like Java or C++ that use class-based inheritance, JavaScript uses
            <strong>prototypal
                inheritance</strong>. Every object in JavaScript has an internal link to another object called its
            prototype. When you try to access a property on an object, JavaScript first looks at the object itself, then
            walks up the prototype chain until it finds the property or reaches the end of the chain.
        </p>

        <pre><code class="language-javascript">const animal = {
    eats: true,
    walk() {
        console.log('Animal walks');
    }
};

const rabbit = {
    jumps: true
};

rabbit.__proto__ = animal;

console.log(rabbit.eats);  // true (inherited)
console.log(rabbit.jumps); // true (own property)
rabbit.walk();             // "Animal walks"</code></pre>

        <p>When we access <code>rabbit.eats</code>, JavaScript doesn't find it on the rabbit object, so it looks at
            rabbit's prototype (animal) and finds it there. This is the prototype chain in action.</p>

        <h3>ES6 Classes: The Modern Way</h3>
        <p>ES6 introduced class syntax that makes inheritance much cleaner and more intuitive:</p>

        <pre><code class="language-javascript">class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Call parent constructor
        this.breed = breed;
    }
    
    speak() {
        console.log(`${this.name} barks`);
    }
    
    fetch() {
        console.log(`${this.name} fetches the ball`);
    }
}

const rex = new Dog('Rex', 'German Shepherd');
rex.speak();  // "Rex barks"
rex.fetch();  // "Rex fetches the ball"</code></pre>

        <p>The <code>extends</code> keyword sets up the inheritance, and <code>super()</code> calls the parent
            constructor.
            Much cleaner than the old constructor function approach!</p>

        <h3>The super Keyword</h3>
        <p>The <code>super</code> keyword is your gateway to parent class functionality:</p>

        <pre><code class="language-javascript">class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} makes a sound`;
    }
}

class Dog extends Animal {
    speak() {
        const parentMessage = super.speak();
        return `${parentMessage} - specifically, a bark!`;
    }
}

const dog = new Dog('Buddy');
console.log(dog.speak()); 
// "Buddy makes a sound - specifically, a bark!"</code></pre>

        <p><strong>Important:</strong> You must call <code>super()</code> before using <code>this</code> in a child
            constructor. The parent needs to initialize the object first.</p>

        <h3>Real-World Example: User Roles</h3>
        <p>Here's a practical example showing inheritance in action:</p>

        <pre><code class="language-javascript">class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }
    
    getInfo() {
        return `${this.name} (${this.email})`;
    }
    
    canEdit() {
        return false;
    }
}

class Admin extends User {
    constructor(name, email, department) {
        super(name, email);
        this.department = department;
    }
    
    canEdit() {
        return true;
    }
    
    getInfo() {
        return `${super.getInfo()} - Admin (${this.department})`;
    }
}

const admin = new Admin('Bob', 'bob@example.com', 'IT');
console.log(admin.getInfo()); // "Bob (bob@example.com) - Admin (IT)"
console.log(admin.canEdit());  // true</code></pre>

        <h3>Method Overriding</h3>
        <p>Child classes can override parent methods to provide specialized behavior:</p>

        <pre><code class="language-javascript">class Shape {
    constructor(color) {
        this.color = color;
    }
    
    getArea() {
        return 0;
    }
}

class Circle extends Shape {
    constructor(color, radius) {
        super(color);
        this.radius = radius;
    }
    
    getArea() {
        return Math.PI * this.radius ** 2;
    }
}

const circle = new Circle('red', 5);
console.log(circle.getArea()); // 78.54...</code></pre>

        <h3>Best Practices</h3>
        <ol>
            <li><strong>Keep hierarchies shallow</strong> - Limit inheritance to 2-3 levels maximum</li>
            <li><strong>Favor composition over inheritance</strong> - Don't create deep inheritance trees</li>
            <li><strong>Use clear "is-a" relationships</strong> - Dog is-a Animal makes sense</li>
            <li><strong>Document your hierarchy</strong> - Use JSDoc to document inheritance relationships</li>
        </ol>

        <h3>When to Use Inheritance</h3>
        <p><strong>Use it when:</strong></p>
        <ul>
            <li>You have a clear "is-a" relationship</li>
            <li>Child classes are specialized versions of the parent</li>
            <li>You want to share common behavior</li>
            <li>You're modeling real-world hierarchies</li>
        </ul>

        <p><strong>Avoid it when:</strong></p>
        <ul>
            <li>You have a "has-a" relationship (use composition)</li>
            <li>The hierarchy would be more than 3 levels deep</li>
            <li>Classes don't share meaningful behavior</li>
        </ul>

        <h3>Key Takeaways</h3>
        <ul>
            <li>JavaScript uses prototypal inheritance, not classical inheritance</li>
            <li>ES6 classes provide clean syntax but use prototypes under the hood</li>
            <li>Use <code>extends</code> to create child classes</li>
            <li>Always call <code>super()</code> before using <code>this</code> in child constructors</li>
            <li>Use <code>super.method()</code> to call parent methods</li>
            <li>Child classes can override parent methods</li>
            <li>Keep inheritance hierarchies shallow</li>
            <li>Favor composition over inheritance for complex relationships</li>
        </ul>
    </div>



    <!-- Chapter 10 -->
    <div id="chapter10" class="page-break">
        <h1>Chapter 10: JavaScript Polymorphism</h1>
        <h2>Write Flexible, Reusable Code</h2>

        <p>If you've been writing JavaScript for a while, you've probably used polymorphism without even realizing it.
            It's one of those concepts that sounds intimidating but is actually quite natural in JavaScript. Let me show
            you why it matters and how to use it effectively.</p>

        <h3>What is Polymorphism?</h3>
        <p>Polymorphism comes from Greek: "poly" (many) + "morph" (form), meaning "many forms." In programming, it means
            writing code that works with different types of objects through a common interface.</p>

        <p>Unlike Java or C++ where polymorphism relies on inheritance and strict type hierarchies, JavaScript uses
            <strong>duck typing</strong>: "If it walks like a duck and quacks like a duck, it's a duck." JavaScript
            doesn't care about an object's typeâonly what methods it has.
        </p>

        <pre><code class="language-javascript">// Different objects with the same interface
const dog = {
    speak() { return 'Woof!'; }
};

const cat = {
    speak() { return 'Meow!'; }
};

const robot = {
    speak() { return 'Beep boop!'; }
};

// Polymorphic function - works with any object that has speak()
function makeItSpeak(animal) {
    console.log(animal.speak());
}

makeItSpeak(dog);    // Woof!
makeItSpeak(cat);    // Meow!
makeItSpeak(robot);  // Beep boop!</code></pre>

        <p>The <code>makeItSpeak</code> function doesn't check types. It only cares that the object has a
            <code>speak()</code> method. This is polymorphism in action.
        </p>

        <h3>Duck Typing in Practice</h3>
        <p>Duck typing makes JavaScript incredibly flexible. Instead of checking an object's type, you check for
            specific
            methods or properties:</p>

        <pre><code class="language-javascript">function draw(shape) {
    if (typeof shape.draw === 'function') {
        shape.draw();
    } else {
        console.error('Object is not drawable');
    }
}

const circle = {
    radius: 5,
    draw() {
        console.log(`Drawing circle with radius ${this.radius}`);
    }
};

const square = {
    side: 10,
    draw() {
        console.log(`Drawing square with side ${this.side}`);
    }
};

draw(circle);  // Drawing circle with radius 5
draw(square);  // Drawing square with side 10</code></pre>

        <p>This pattern is everywhere in JavaScript. Promises work with any "thenable" (object with a
            <code>then()</code>
            method). Iterators work with any object that has a <code>next()</code> method. Array methods work with any
            array-like object.
        </p>

        <h3>Real-World Example: Payment Processing</h3>
        <p>Here's a practical example that shows polymorphism's power:</p>

        <pre><code class="language-javascript">class PaymentProcessor {
    processPayment(paymentMethod, amount) {
        if (typeof paymentMethod.pay !== 'function') {
            throw new Error('Invalid payment method');
        }
        return paymentMethod.pay(amount);
    }
}

class CreditCard {
    constructor(cardNumber) {
        this.cardNumber = cardNumber;
    }
    
    pay(amount) {
        console.log(`Charging $${amount} to card ending in ${this.cardNumber.slice(-4)}`);
        return { success: true, method: 'credit_card' };
    }
}

class PayPal {
    constructor(email) {
        this.email = email;
    }
    
    pay(amount) {
        console.log(`Processing $${amount} PayPal payment for ${this.email}`);
        return { success: true, method: 'paypal' };
    }
}

// Usage
const processor = new PaymentProcessor();
processor.processPayment(new CreditCard('1234567890123456'), 100);
processor.processPayment(new PayPal('user@example.com'), 50);</code></pre>

        <p>The <code>PaymentProcessor</code> doesn't need to know about specific payment types. It only needs objects
            with
            a <code>pay()</code> method. Adding new payment methods requires zero changes to the processor.</p>

        <h3>Polymorphism with Classes</h3>
        <p>You can also use ES6 classes for more traditional OOP-style polymorphism:</p>

        <pre><code class="language-javascript">class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} makes a sound`;
    }
}

class Dog extends Animal {
    speak() {
        return `${this.name} barks`;
    }
}

class Cat extends Animal {
    speak() {
        return `${this.name} meows`;
    }
}

function describeAnimal(animal) {
    console.log(animal.speak());
}

describeAnimal(new Dog('Rex'));      // Rex barks
describeAnimal(new Cat('Whiskers')); // Whiskers meows</code></pre>

        <p>Each subclass overrides <code>speak()</code> with its own implementation. The <code>describeAnimal</code>
            function works with any Animal, regardless of the specific subclass.</p>

        <h3>Best Practices</h3>
        <ol>
            <li><strong>Design around interfaces</strong> - Think about what methods objects need, not what type they
                are
            </li>
            <li><strong>Use consistent method names</strong> - If objects do similar things, give them the same method
                names</li>
            <li><strong>Validate interfaces</strong> - Always check that objects have the methods you need</li>
            <li><strong>Document expectations</strong> - Use JSDoc to document what methods objects should implement
            </li>
            <li><strong>Consider TypeScript</strong> - For large projects, TypeScript's interfaces provide compile-time
                checking</li>
        </ol>

        <h3>When to Use Polymorphism</h3>
        <p><strong>Use it when:</strong></p>
        <ul>
            <li>You have multiple objects that do similar things differently</li>
            <li>You want functions that work with many types</li>
            <li>You're building plugin systems or extensible architectures</li>
            <li>You want to reduce code duplication</li>
        </ul>

        <p><strong>Avoid it when:</strong></p>
        <ul>
            <li>You only have one type of object</li>
            <li>Objects don't share common behavior</li>
            <li>Simple conditional logic is clearer</li>
            <li>It adds unnecessary complexity</li>
        </ul>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Polymorphism lets different objects be treated through a common interface</li>
            <li>JavaScript uses duck typing - objects are defined by their methods, not types</li>
            <li>Design around interfaces (sets of methods) rather than specific types</li>
            <li>Always validate that objects have the methods you need</li>
            <li>Use consistent method names across similar objects</li>
            <li>Don't over-engineer - use polymorphism where it adds value</li>
        </ul>
    </div>



    <!-- Chapter 11: Classes -->
    <div id="chapter11" class="page-break">
        <h1>Chapter 11: JavaScript Classes</h1>
        <h2>Modern Object-Oriented Programming</h2>

        <p>JavaScript classes, introduced in ES6, provide a cleaner, more intuitive syntax for object-oriented
            programming. While classes are syntactic sugar over JavaScript's existing prototype-based inheritance, they
            make the code more readable and familiar to developers coming from other object-oriented languages like Java
            or C++.</p>

        <p>Classes encapsulate data and behavior, making it easier to create multiple instances of similar objects. They
            support inheritance, allowing you to create specialized versions of base classes. Modern JavaScript classes
            also support private fields and methods, providing true encapsulation that was previously difficult to
            achieve.</p>

        <h3>Basic Class Syntax</h3>

        <p>A class is defined using the <code>class</code> keyword, followed by a constructor method that initializes
            new instances. Methods defined in the class are automatically added to the prototype, making them available
            to all instances while being defined only once.</p>

        <pre><code class="language-javascript">class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
}

const user = new User('John', 30);
console.log(user.greet()); // "Hello, I'm John"
</code></pre>

        <h3>Static Methods</h3>

        <p>Static methods belong to the class itself, not to instances. They're called on the class directly and are
            useful for utility functions, factory methods, or operations that don't require instance data. Static
            methods cannot access instance properties or methods using <code>this</code>.</p>

        <pre><code class="language-javascript">class MathUtils {
    static add(a, b) {
        return a + b;
    }
    
    static max(...numbers) {
        return Math.max(...numbers);
    }
}

// Call on class, not instance
console.log(MathUtils.add(5, 3));       // 8
console.log(MathUtils.max(1, 5, 3, 9)); // 9
</code></pre>

        <h3>Getters and Setters</h3>

        <pre><code class="language-javascript">class User {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    
    get fullName() {
        return `${this.firstName} ${this.lastName}`;
    }
    
    set fullName(name) {
        [this.firstName, this.lastName] = name.split(' ');
    }
}

const user = new User('John', 'Doe');
console.log(user.fullName); // "John Doe"
user.fullName = 'Jane Smith';
console.log(user.firstName); // "Jane"
</code></pre>

        <h3>Inheritance with extends</h3>

        <p>The <code>extends</code> keyword creates a subclass that inherits properties and methods from a parent class.
            This enables code reuse and the creation of specialized versions of base classes. The child class can
            override parent methods or add new ones, while still having access to parent functionality through
            <code>super</code>.
        </p>

        <pre><code class="language-javascript">class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} makes a sound`;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Call parent constructor
        this.breed = breed;
    }
    
    speak() {
        return `${this.name} barks`;
    }
    
    fetch() {
        return `${this.name} fetches the ball`;
    }
}

const dog = new Dog('Rex', 'German Shepherd');
console.log(dog.speak()); // "Rex barks"
console.log(dog.fetch()); // "Rex fetches the ball"
</code></pre>

        <h3>Private Fields</h3>

        <pre><code class="language-javascript">class BankAccount {
    #balance = 0;
    #pin;
    
    constructor(initialBalance, pin) {
        this.#balance = initialBalance;
        this.#pin = pin;
    }
    
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            return true;
        }
        return false;
    }
    
    withdraw(amount, pin) {
        if (pin !== this.#pin) {
            throw new Error('Invalid PIN');
        }
        if (amount > this.#balance) {
            throw new Error('Insufficient funds');
        }
        this.#balance -= amount;
        return amount;
    }
    
    getBalance(pin) {
        if (pin !== this.#pin) {
            throw new Error('Invalid PIN');
        }
        return this.#balance;
    }
}

const account = new BankAccount(1000, '1234');
account.deposit(500);
console.log(account.getBalance('1234')); // 1500
</code></pre>

        <h3>Real-World Example: API Client</h3>

        <pre><code class="language-javascript">class ApiClient {
    constructor(baseUrl, options = {}) {
        this.baseUrl = baseUrl;
        this.timeout = options.timeout || 5000;
        this.headers = options.headers || {};
    }
    
    async request(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const config = {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...this.headers,
                ...options.headers
            }
        };
        
        const response = await fetch(url, config);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        return response.json();
    }
    
    async get(endpoint) {
        return this.request(endpoint);
    }
    
    async post(endpoint, data) {
        return this.request(endpoint, {
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
}

const api = new ApiClient('https://api.example.com');
const users = await api.get('/users');
const newUser = await api.post('/users', { name: 'John' });
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Classes provide clean OOP syntax</li>
            <li>Constructor initializes instances</li>
            <li>Static methods/properties belong to class, not instances</li>
            <li>Getters/setters provide computed properties</li>
            <li>extends enables inheritance</li>
            <li>super calls parent class constructor/methods</li>
            <li>Private fields (#) enforce encapsulation</li>
            <li>Classes are syntactic sugar over prototypes</li>
            <li>Modern standard for OOP in JavaScript</li>
        </ul>
    </div>


    <!-- PART IV -->
    <div class="page-break">
        <h1 class="center">Part IV</h1>
        <h2 class="center">Asynchronous JavaScript</h2>
    </div>

    <!-- Chapter 11 -->
    <div id="chapter12" class="page-break">
        <h1>Chapter 12: JavaScript Event Loop</h1>
        <h2>Master Asynchronous Execution</h2>

        <p>JavaScript is single-threaded, meaning it can only execute one piece of code at a time. Yet it handles
            asynchronous operations like network requests, timers, and user interactions without blocking. How? The
            <strong>Event Loop</strong>.
        </p>

        <p>The Event Loop is a mechanism that coordinates the execution of code, handling events, and executing queued
            tasks. It's what makes JavaScript's non-blocking asynchronous behavior possible.</p>

        <h3>The Components</h3>

        <p><strong>1. The Call Stack</strong></p>
        <p>The call stack is where JavaScript keeps track of function execution. When a function is called, it's pushed
            onto the stack. When it returns, it's popped off.</p>

        <pre><code class="language-javascript">function first() {
    console.log('First');
}

function second() {
    first();
    console.log('Second');
}

second();
// Call stack: second() â first() â pops â second() pops
</code></pre>

        <p><strong>2. Web APIs / Browser APIs</strong></p>
        <p>When you call <code>setTimeout</code>, make a fetch request, or add an event listener, these operations are
            handled by the browser's Web APIs, not JavaScript itself.</p>

        <pre><code class="language-javascript">console.log('Start');
setTimeout(() => console.log('Timeout'), 0);
console.log('End');

// Output: Start, End, Timeout (even with 0ms delay!)
</code></pre>

        <p><strong>3. The Task Queue (Macrotask Queue)</strong></p>
        <p>When Web APIs complete, their callbacks are placed in the task queue. The Event Loop moves tasks from the
            queue to the stack when the stack is empty.</p>
        <p>Macrotasks include: <code>setTimeout</code>, <code>setInterval</code>, I/O operations, UI rendering.</p>

        <p><strong>4. The Microtask Queue</strong></p>
        <p>Microtasks have <strong>higher priority</strong> than macrotasks. After each macrotask, the Event Loop
            processes <em>all</em> microtasks before moving to the next macrotask.</p>
        <p>Microtasks include: Promise callbacks (<code>.then</code>, <code>.catch</code>, <code>.finally</code>),
            <code>queueMicrotask()</code>, <code>MutationObserver</code>.
        </p>

        <h3>The Event Loop in Action</h3>

        <pre><code class="language-javascript">console.log('1: Sync');

setTimeout(() => {
    console.log('2: setTimeout');
}, 0);

Promise.resolve().then(() => {
    console.log('3: Promise');
});

console.log('4: Sync');

// Output:
// 1: Sync
// 4: Sync
// 3: Promise
// 2: setTimeout
</code></pre>

        <p><strong>Execution order:</strong></p>
        <ol>
            <li>Synchronous code executes first</li>
            <li>Call stack is empty, check microtask queue</li>
            <li>Promise callback executes</li>
            <li>Microtask queue empty, check task queue</li>
            <li>setTimeout callback executes</li>
        </ol>

        <h3>Complex Example</h3>

        <pre><code class="language-javascript">console.log('Start');

setTimeout(() => {
    console.log('Timeout 1');
    Promise.resolve().then(() => console.log('Promise in Timeout 1'));
}, 0);

Promise.resolve()
    .then(() => {
        console.log('Promise 1');
        setTimeout(() => console.log('Timeout in Promise 1'), 0);
    })
    .then(() => console.log('Promise 2'));

setTimeout(() => console.log('Timeout 2'), 0);

console.log('End');

// Output:
// Start, End
// Promise 1, Promise 2
// Timeout 1, Promise in Timeout 1
// Timeout in Promise 1, Timeout 2
</code></pre>

        <h3>Async/Await and the Event Loop</h3>

        <p><code>async/await</code> is syntactic sugar over Promises, so it follows the same microtask rules:</p>

        <pre><code class="language-javascript">console.log('1');

async function asyncFunc() {
    console.log('2');
    await Promise.resolve();
    console.log('3'); // This is a microtask
}

asyncFunc();
Promise.resolve().then(() => console.log('4'));
console.log('5');

// Output: 1, 2, 5, 3, 4
</code></pre>

        <p>Everything after <code>await</code> is scheduled as a microtask, just like <code>.then()</code>.</p>

        <h3>Common Pitfalls</h3>

        <p><strong>Pitfall 1: Assuming setTimeout(fn, 0) executes immediately</strong></p>
        <p>It doesn't! It's queued as a macrotask and waits for the call stack and all microtasks to clear.</p>

        <p><strong>Pitfall 2: Infinite microtask loops</strong></p>
        <pre><code class="language-javascript">function recursiveMicrotask() {
    Promise.resolve().then(recursiveMicrotask);
}
recursiveMicrotask(); // Blocks the Event Loop!
</code></pre>
        <p>This creates an infinite microtask queue, preventing macrotasks (like UI updates) from ever executing.</p>

        <p><strong>Pitfall 3: Blocking the main thread</strong></p>
        <pre><code class="language-javascript">// Bad: blocks for 3 seconds
const start = Date.now();
while (Date.now() - start < 3000) {}
console.log('Done'); // UI is frozen
</code></pre>

        <h3>Best Practices</h3>

        <p><strong>1. Break up long tasks</strong></p>
        <pre><code class="language-javascript">async function processItems(items) {
    for (let i = 0; i < items.length; i += 100) {
        const batch = items.slice(i, i + 100);
        await processBatch(batch);
        // Yields to Event Loop between batches
    }
}
</code></pre>

        <p><strong>2. Use microtasks for high-priority work</strong></p>
        <pre><code class="language-javascript">// High priority
queueMicrotask(() => {
    // Executes before next macrotask
});

// Lower priority
setTimeout(() => {
    // Executes after microtasks
}, 0);
</code></pre>

        <p><strong>3. Understand execution order for debugging</strong></p>
        <p>When debugging async issues, trace through:</p>
        <ol>
            <li>All synchronous code</li>
            <li>All microtasks (Promises, async/await)</li>
            <li>One macrotask (setTimeout, etc.)</li>
            <li>Repeat steps 2-3</li>
        </ol>

        <h3>Key Takeaways</h3>
        <ul>
            <li>JavaScript is single-threaded but non-blocking thanks to the Event Loop</li>
            <li>The call stack executes synchronous code</li>
            <li>Web APIs handle async operations in parallel</li>
            <li>Microtasks (Promises) have higher priority than macrotasks (setTimeout)</li>
            <li>The Event Loop processes: sync code â all microtasks â one macrotask â repeat</li>
            <li>Understanding the Event Loop helps you write better async code and debug timing issues</li>
            <li>Avoid blocking the main thread with long-running synchronous operations</li>
        </ul>
    </div>


    <!-- Chapter 12 -->
    <div id="chapter13" class="page-break">
        <h1>Chapter 13: JavaScript Promises</h1>
        <h2>From Callback Hell to Async Heaven</h2>

        <p>Remember the days of callback pyramids that looked like the Leaning Tower of Pisa? If you've been writing
            JavaScript for a while, you probably do. Promises fundamentally changed how we handle asynchronous
            operations
            in JavaScript, transforming messy, nested callbacks into clean, readable code. They're now so central to
            modern JavaScript that it's hard to imagine working without them.</p>

        <p>Promises aren't just a syntactic improvement - they represent a conceptual shift in how we think about
            asynchronous code. Instead of passing callbacks that will be called "someday," we get back a promise object
            that represents a value that will be available "someday." This shift from callbacks to values makes
            asynchronous code much easier to reason about and compose.</p>

        <h3>The Problem: Callback Hell</h3>
        <p>Before Promises, the standard way to handle asynchronous operations was through callbacks - functions you
            pass
            to other functions to be called when the operation completes. This worked, but it led to deeply nested code
            that was difficult to read and maintain:</p>

        <pre><code class="language-javascript">getData(function(a) {
    getMoreData(a, function(b) {
        getMoreData(b, function(c) {
            getMoreData(c, function(d) {
                getMoreData(d, function(e) {
                    // Finally do something
                });
            });
        });
    });
});</code></pre>

        <p>This "pyramid of doom" or "callback hell" has several problems beyond just looking ugly. Error handling is
            difficult - you need to handle errors at each level. The code doesn't read top-to-bottom like synchronous
            code. And trying to do things like running operations in parallel or racing them against each other becomes
            incredibly complex.</p>

        <p>The fundamental issue is that callbacks invert the control flow. Instead of your code calling functions and
            getting results, you're giving control to other functions and hoping they call your callbacks correctly.
            This
            inversion of control makes code harder to understand and more prone to bugs.</p>

        <h3>Enter Promises</h3>
        <p>A Promise is an object representing the eventual completion (or failure) of an asynchronous operation.
            Instead
            of passing a callback to a function, the function returns a Promise object that you can attach callbacks to.
            This simple shift restores normal control flow and makes asynchronous code much easier to work with.</p>

        <pre><code class="language-javascript">const promise = new Promise((resolve, reject) => {
    // Async operation
    if (success) {
        resolve(value);
    } else {
        reject(error);
    }
});</code></pre>

        <p>A Promise can be in one of three states, and it can only transition once - from pending to either fulfilled
            or rejected. Once settled (fulfilled or rejected), a Promise's state never changes:</p>

        <ul>
            <li><strong>Pending</strong> - Initial state, operation hasn't completed yet</li>
            <li><strong>Fulfilled</strong> - Operation completed successfully, promise has a value</li>
            <li><strong>Rejected</strong> - Operation failed, promise has a reason (error)</li>
        </ul>

        <p>This state machine model makes Promises predictable. You know that a Promise will eventually settle, and once
            it does, its value or error is immutable. This immutability is crucial for composing asynchronous operations
            reliably.</p>

        <h3>Using Promises</h3>
        <p>The real power of Promises comes from how you use them. The <code>.then()</code> method lets you attach
            callbacks that run when the Promise fulfills, and <code>.catch()</code> handles errors. The key insight is
            that <code>.then()</code> returns a new Promise, enabling chaining:</p>

        <pre><code class="language-javascript">fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => {
        console.log(data);
        return processData(data);
    })
    .then(result => {
        console.log(result);
    })
    .catch(error => {
        console.error('Error:', error);
    })
    .finally(() => {
        console.log('Cleanup');
    });</code></pre>

        <p>Much cleaner! The code reads top-to-bottom like synchronous code, and error handling is centralized in a
            single <code>.catch()</code> block. The <code>.finally()</code> method runs regardless of whether the
            Promise
            fulfilled or rejected, perfect for cleanup operations like hiding loading spinners.</p>

        <p>Each <code>.then()</code> in the chain receives the value from the previous Promise. If you return a value
            from a <code>.then()</code> callback, it's wrapped in a Promise automatically. If you return a Promise, the
            next <code>.then()</code> waits for that Promise to settle. This makes sequential async operations natural
            to express.</p>

        <h3>Creating Promises</h3>
        <p>While many APIs return Promises (like <code>fetch()</code>), you'll sometimes need to create your own. The
            Promise constructor takes a function with two parameters: <code>resolve</code> and <code>reject</code>. Call
            <code>resolve(value)</code> when the operation succeeds, or <code>reject(error)</code> when it fails:
        </p>

        <pre><code class="language-javascript">function delay(ms) {
    return new Promise(resolve => {
        setTimeout(resolve, ms);
    });
}

delay(1000).then(() => console.log('1 second later'));</code></pre>

        <p>This simple <code>delay</code> function wraps <code>setTimeout</code> in a Promise, making it chainable with
            other async operations. This pattern of "promisifying" callback-based APIs is common when working with older
            code.</p>

        <h3>Chaining Promises</h3>
        <p>Promise chaining is where the real power emerges. Each <code>.then()</code> returns a new Promise, so you can
            chain operations that depend on previous results. This transforms nested callbacks into a flat, readable
            chain:</p>

        <pre><code class="language-javascript">function getUserData(userId) {
    return fetch(`/api/users/${userId}`)
        .then(response => response.json());
}

function getUserPosts(userId) {
    return fetch(`/api/users/${userId}/posts`)
        .then(response => response.json());
}

getUserData(1)
    .then(user => {
        console.log('User:', user);
        return getUserPosts(user.id);
    })
    .then(posts => {
        console.log('Posts:', posts);
    })
    .catch(error => {
        console.error('Error:', error);
    });</code></pre>

        <p>The key is that when you return a Promise from a <code>.then()</code> callback, the next <code>.then()</code>
            waits for that Promise to settle. This makes sequential async operations natural - first get the user, then
            use the user's ID to get their posts. A single <code>.catch()</code> at the end handles errors from any step
            in the chain.</p>

        <h3>Promise.all() - Parallel Execution</h3>
        <p>When you have multiple independent async operations, you don't want to wait for them sequentially - that
            would
            be slow. <code>Promise.all()</code> runs them in parallel and waits for all to complete:</p>

        <pre><code class="language-javascript">const promise1 = fetch('/api/users');
const promise2 = fetch('/api/posts');
const promise3 = fetch('/api/comments');

Promise.all([promise1, promise2, promise3])
    .then(([users, posts, comments]) => {
        console.log('All data loaded');
    })
    .catch(error => {
        console.error('One failed:', error);
    });</code></pre>

        <p><strong>Important:</strong> <code>Promise.all()</code> rejects immediately if ANY promise rejects. This
            "fail-fast" behavior is useful when all operations must succeed, but it means one failure cancels
            everything.
            If you need more resilient behavior, consider <code>Promise.allSettled()</code>, which waits for all
            Promises
            regardless of whether they fulfill or reject.</p>

        <h3>Promise.race() - First to Finish</h3>
        <p><code>Promise.race()</code> returns a Promise that settles as soon as the first Promise in the array settles.
            This is useful for implementing timeouts or racing multiple data sources:</p>

        <pre><code class="language-javascript">const timeout = new Promise((_, reject) => 
    setTimeout(() => reject('Timeout'), 5000)
);

const request = fetch('/api/data');

Promise.race([request, timeout])
    .then(data => console.log('Success:', data))
    .catch(error => console.error('Error:', error));</code></pre>

        <p>This pattern ensures your request completes within 5 seconds or times out. Whichever Promise settles first
            (the fetch or the timeout) determines the result. This is particularly useful for providing good user
            experience by not letting requests hang indefinitely.</p>

        <h3>Async/Await - Promises Made Easy</h3>
        <p>ES2017 introduced <code>async</code>/<code>await</code>, which is syntactic sugar over Promises that makes
            asynchronous code look and behave more like synchronous code. An <code>async</code> function always returns
            a
            Promise, and <code>await</code> pauses execution until a Promise settles:</p>

        <pre><code class="language-javascript">async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        const user = await response.json();
        
        const postsResponse = await fetch(`/api/users/${userId}/posts`);
        const posts = await postsResponse.json();
        
        return { user, posts };
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}

// Usage
fetchUserData(1)
    .then(data => console.log(data))
    .catch(error => console.error(error));</code></pre>

        <p>The <code>await</code> keyword makes async code read like synchronous code - you write sequential operations
            line by line without <code>.then()</code> chains. Error handling uses familiar <code>try/catch</code>
            blocks.
            This is now the preferred way to work with Promises in modern JavaScript, though understanding Promises
            themselves is still essential.</p>

        <h3>Common Pitfalls</h3>
        <p>Even experienced developers make these mistakes with Promises. Understanding these pitfalls will save you
            hours
            of debugging:</p>

        <h4>1. Forgetting to return</h4>
        <p>This is the most common Promise mistake. If you don't return a Promise from a <code>.then()</code> callback,
            the next <code>.then()</code> receives <code>undefined</code> instead of waiting for the async operation:
        </p>

        <pre><code class="language-javascript">// Wrong
promise1.then(data => {
    promise2(data); // Not returned!
}).then(result => {
    // result is undefined
});

// Right
promise1.then(data => {
    return promise2(data);
}).then(result => {
    // result has value
});</code></pre>

        <p>The chain continues immediately without waiting for <code>promise2</code> to complete. Always return Promises
            from <code>.then()</code> callbacks when you want subsequent steps to wait.</p>

        <h4>2. Not handling errors</h4>
        <p>Unhandled Promise rejections are silent by default (though modern environments warn about them). Always add a
            <code>.catch()</code> to handle errors, or they'll disappear into the void:
        </p>

        <pre><code class="language-javascript">// Wrong
fetch('/api/data')
    .then(response => response.json())
    .then(data => console.log(data));
// Errors are silently swallowed!

// Right
fetch('/api/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error(error));</code></pre>

        <p>Without <code>.catch()</code>, network failures, parsing errors, or any other problems will fail silently,
            making debugging extremely difficult. Always handle errors explicitly.</p>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Promises represent future values</li>
            <li>Three states: pending, fulfilled, rejected</li>
            <li>Chain with <code>.then()</code>, handle errors with <code>.catch()</code></li>
            <li><code>Promise.all()</code> for parallel execution</li>
            <li><code>async</code>/<code>await</code> makes Promises easier to read</li>
            <li>Always handle errors</li>
            <li>Always return from <code>.then()</code> when chaining</li>
        </ul>
    </div>



    <!-- Chapter 15: async/await -->
    <div id="chapter14" class="page-break">
        <h1>Chapter 14: JavaScript async/await</h1>
        <h2>Modern Asynchronous JavaScript</h2>

        <p>The async/await syntax provides a cleaner, more readable way to work with Promises. It makes asynchronous
            code look and behave more like synchronous code, making it easier to understand and maintain.</p>

        <h3>Basic Syntax</h3>

        <p>An async function always returns a Promise. Inside an async function, you can use the await keyword to pause
            execution until a Promise resolves.</p>

        <pre><code>// Traditional Promise syntax
function getUser() {
    return fetch('/api/user')
        .then(response => response.json())
        .then(user => {
            console.log(user);
            return user;
        })
        .catch(error => {
            console.error(error);
        });
}

// With async/await
async function getUser() {
    try {
        const response = await fetch('/api/user');
        const user = await response.json();
        console.log(user);
        return user;
    } catch (error) {
        console.error(error);
    }
}</code></pre>

        <h3>Error Handling</h3>

        <p>Use try/catch blocks to handle errors in async functions, just like synchronous code.</p>

        <h3>Key Takeaways</h3>
        <ul>
            <li>async functions always return Promises</li>
            <li>await pauses execution until Promise resolves</li>
            <li>Use try/catch for error handling</li>
            <li>Makes async code more readable</li>
            <li>Can use Promise.all() with await for parallel execution</li>
        </ul>
    </div>




    <!-- Chapter 13 -->
    <div id="chapter14" class="page-break">
        <h1>Chapter 15: JavaScript Generators</h1>
        <h2>The Underrated Feature That Will Change How You Code</h2>

        <p>If you've been writing JavaScript for a while, you've probably heard of generators. Maybe you've even seen
            the <code>function*</code> syntax and wondered what it does. Generators are one of JavaScript's most
            powerful yet underused features, often overlooked because they seem complex or niche. But once you
            understand
            them, you'll discover they solve problems that are difficult or impossible to solve elegantly with regular
            functions.</p>

        <p>Generators fundamentally change the execution model of functions. While regular functions run from start to
            finish in one go, generators can pause in the middle, return a value, and then resume exactly where they
            left
            off. This ability to pause and resume opens up entirely new patterns for handling iteration, lazy
            evaluation,
            and complex control flow.</p>

        <h3>What is a Generator?</h3>
        <p>A generator is a special type of function that can pause and resume its execution. Unlike regular functions
            that run to completion and return a single value, generators can yield multiple values over time, pausing
            after each yield and resuming when asked for the next value:</p>

        <pre><code class="language-javascript">function* countToThree() {
    yield 1;
    yield 2;
    yield 3;
}

const counter = countToThree();
console.log(counter.next()); // { value: 1, done: false }
console.log(counter.next()); // { value: 2, done: false }
console.log(counter.next()); // { value: 3, done: false }
console.log(counter.next()); // { value: undefined, done: true }</code></pre>

        <p>The <code>function*</code> syntax (note the asterisk) creates a generator function. When you call a generator
            function, it doesn't execute immediately. Instead, it returns a generator object that implements the
            iterator
            protocol. Each call to <code>.next()</code> runs the generator until it hits a <code>yield</code> statement,
            returns the yielded value, and pauses. The next <code>.next()</code> call resumes from exactly where it
            paused.</p>

        <p>The returned object has two properties: <code>value</code> (the yielded value) and <code>done</code> (a
            boolean indicating whether the generator has finished). This protocol makes generators work seamlessly with
            JavaScript's iteration features like <code>for...of</code> loops.</p>

        <h3>Why Generators Matter</h3>
        <p>Generators enable patterns that are difficult or inefficient with regular functions. Let's explore four key
            use
            cases that demonstrate their power:</p>

        <h4>1. Lazy Evaluation</h4>
        <p>One of the most powerful features of generators is lazy evaluation - values are computed only when requested,
            not all at once. This enables working with infinite sequences and large datasets without memory concerns:
        </p>

        <pre><code class="language-javascript">function* fibonacci() {
    let a = 0, b = 1;
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

const fib = fibonacci();
console.log(fib.next().value); // 0
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2
console.log(fib.next().value); // 3
// Can generate infinite sequence!</code></pre>

        <p>This Fibonacci generator has an infinite <code>while (true)</code> loop, which would hang a regular function.
            But with a generator, it's perfectly safe - each number is computed only when you call <code>.next()</code>.
            You could generate the millionth Fibonacci number without computing all the previous ones at once. This is
            impossible with arrays or regular functions.</p>

        <h4>2. Custom Iterators</h4>
        <p>Generators make creating custom iterators trivial. Any generator automatically works with
            <code>for...of</code>
            loops and other iteration protocols:
        </p>

        <pre><code class="language-javascript">function* range(start, end) {
    for (let i = start; i <= end; i++) {
        yield i;
    }
}

for (let num of range(1, 5)) {
    console.log(num); // 1, 2, 3, 4, 5
}</code></pre>

        <p>Without generators, implementing a custom iterator requires manually implementing the iterator protocol with
            <code>Symbol.iterator</code> and <code>next()</code> methods - much more verbose. Generators handle all that
            boilerplate for you.
        </p>

        <h4>3. Async Flow Control</h4>
        <p>Before <code>async/await</code> existed, generators were used for handling asynchronous code in a synchronous
            style. Libraries like co and redux-saga still use this pattern:</p>

        <pre><code class="language-javascript">function* fetchData() {
    const user = yield fetch('/api/user');
    const posts = yield fetch(`/api/posts/${user.id}`);
    return posts;
}</code></pre>

        <p>While <code>async/await</code> has largely replaced this use case, understanding it helps you appreciate how
            generators enable control flow manipulation. The generator pauses at each <code>yield</code>, allowing
            external code to handle the Promise and resume with the result.</p>

        <h4>4. State Machines</h4>
        <p>Generators excel at implementing state machines - systems that cycle through a series of states. The
            generator
            naturally maintains state between calls:</p>

        <pre><code class="language-javascript">function* trafficLight() {
    while (true) {
        yield 'red';
        yield 'yellow';
        yield 'green';
    }
}

const light = trafficLight();
console.log(light.next().value); // red
console.log(light.next().value); // yellow
console.log(light.next().value); // green
console.log(light.next().value); // red (cycles)</code></pre>

        <p>The generator remembers where it is in the cycle. Implementing this with regular functions would require
            manually tracking state in external variables. Generators encapsulate the state naturally.</p>

        <h3>Passing Values to Generators</h3>
        <p>Generators aren't just one-way - you can pass values back into them using <code>.next(value)</code>. The
            value
            you pass becomes the result of the <code>yield</code> expression inside the generator:</p>

        <pre><code class="language-javascript">function* echo() {
    const input1 = yield 'Ready';
    console.log(`Got: ${input1}`);
    
    const input2 = yield 'Waiting';
    console.log(`Got: ${input2}`);
}

const gen = echo();
console.log(gen.next());        // { value: 'Ready', done: false }
console.log(gen.next('Hello')); // Got: Hello, { value: 'Waiting', done: false }
console.log(gen.next('World')); // Got: World, { value: undefined, done: true }</code></pre>

        <p>This bidirectional communication enables powerful patterns. The generator yields a value out, pauses, and
            when
            resumed with <code>.next(value)</code>, that value becomes the result of the yield expression. This creates
            a
            conversation between the generator and the calling code.</p>

        <h3>Real-World Example: Pagination</h3>
        <p>Here's a practical example that demonstrates lazy evaluation and custom iteration. This generator lazily
            creates pages from a dataset, computing each page only when requested:</p>

        <pre><code class="language-javascript">function* paginate(items, pageSize) {
    for (let i = 0; i < items.length; i += pageSize) {
        yield items.slice(i, i + pageSize);
    }
}

const items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const pages = paginate(items, 3);

console.log(pages.next().value); // [1, 2, 3]
console.log(pages.next().value); // [4, 5, 6]
console.log(pages.next().value); // [7, 8, 9]
console.log(pages.next().value); // [10]</code></pre>

        <p>This is perfect for implementing "load more" functionality or processing large datasets in chunks. Each page
            is
            created on demand, so you never load the entire dataset into memory at once. You could paginate millions of
            items efficiently.</p>

        <h3>Generator Delegation</h3>
        <p>The <code>yield*</code> syntax allows one generator to delegate to another, yielding all values from the
            delegated generator. This is useful for composing generators and building complex iteration patterns from
            simpler ones:</p>

        <pre><code class="language-javascript">function* gen1() {
    yield 1;
    yield 2;
}

function* gen2() {
    yield* gen1(); // Delegate to gen1
    yield 3;
    yield 4;
}

const gen = gen2();
console.log([...gen]); // [1, 2, 3, 4]</code></pre>

        <p>The <code>yield*</code> expression delegates to another iterable (generator, array, etc.) and yields all its
            values before continuing. This makes it easy to compose generators, similar to how you compose functions.
            You
            can build complex iteration logic by combining simple, reusable generator functions.</p>

        <h3>When to Use Generators</h3>
        <p>Generators are powerful, but they're not always the right tool. Here's guidance on when to use them and when
            simpler alternatives are better:</p>

        <p><strong>Use generators when:</strong></p>
        <ul>
            <li><strong>Working with large or infinite sequences</strong> - Lazy evaluation prevents memory issues</li>
            <li><strong>Implementing custom iterators</strong> - Much simpler than manual iterator protocol</li>
            <li><strong>Need lazy evaluation</strong> - Compute values only when needed</li>
            <li><strong>Building state machines</strong> - Natural way to model state transitions</li>
            <li><strong>Creating data pipelines</strong> - Compose transformations efficiently</li>
        </ul>

        <p><strong>Skip generators when:</strong></p>
        <ul>
            <li><strong>Simple iteration is enough</strong> - Arrays and <code>for</code> loops are clearer</li>
            <li><strong>Team is unfamiliar with the syntax</strong> - Code readability matters</li>
            <li><strong>Performance is critical</strong> - Regular loops have less overhead (though the difference is
                usually negligible)</li>
        </ul>

        <p>The key is to use generators where they genuinely simplify your code or enable patterns that would be
            difficult
            otherwise. Don't use them just because they're clever - use them because they solve a real problem
            elegantly.</p>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Generators can pause and resume execution</li>
            <li>Use <code>function*</code> syntax and <code>yield</code> keyword</li>
            <li>Perfect for lazy evaluation and infinite sequences</li>
            <li>Great for custom iterators</li>
            <li>Can pass values back and forth</li>
            <li>Use <code>yield*</code> for delegation</li>
            <li>Modern async/await replaced generators for async code</li>
        </ul>
    </div>


    <!-- PART V -->
    <div class="page-break">
        <h1 class="center">Part V</h1>
        <h2 class="center">Modern JavaScript Syntax</h2>
    </div>

    <!-- Chapter 16: Destructuring -->
    <div id="chapter16" class="page-break">
        <h1>Chapter 16: JavaScript Destructuring</h1>
        <h2>Extract Values with Ease</h2>

        <p>Destructuring is a powerful JavaScript expression introduced in ES6 that allows you to unpack values from
            arrays or properties from objects into distinct variables. This feature dramatically improves code
            readability and reduces the amount of repetitive code you need to write when working with complex data
            structures.</p>

        <p>Before destructuring, extracting multiple values from arrays or objects required verbose, repetitive code.
            Destructuring provides a concise syntax that makes your intentions clear and your code more maintainable.
            It's particularly useful when working with function parameters, API responses, and configuration objects.
        </p>

        <h3>Array Destructuring</h3>

        <p>Array destructuring allows you to extract values from arrays based on their position. The syntax uses square
            brackets on the left side of an assignment, with variable names corresponding to array positions.</p>

        <p><strong>Basic Array Destructuring:</strong></p>

        <pre><code class="language-javascript">// Without destructuring
const colors = ['red', 'green', 'blue'];
const first = colors[0];
const second = colors[1];

// With destructuring
const [first, second, third] = colors;
console.log(first);  // 'red'
console.log(second); // 'green'
console.log(third);  // 'blue'
</code></pre>

        <p>This simple example shows how destructuring eliminates the need for bracket notation and index access.
            Instead of writing <code>colors[0]</code>, <code>colors[1]</code>, etc., you can extract all values in a
            single, readable line.</p>

        <p><strong>Skipping Elements:</strong></p>

        <p>Sometimes you only need specific elements from an array. Destructuring allows you to skip unwanted elements
            by leaving empty spaces between commas. This is particularly useful when working with arrays where you only
            care about certain positions.</p>

        <pre><code class="language-javascript">const colors = ['red', 'green', 'blue', 'yellow'];

// Skip elements with commas
const [first, , third] = colors;
console.log(first); // 'red'
console.log(third); // 'blue'

// Get first and rest
const [primary, ...others] = colors;
console.log(primary); // 'red'
console.log(others);  // ['green', 'blue', 'yellow']
</code></pre>

        <h3>Object Destructuring</h3>

        <p>Object destructuring is even more powerful than array destructuring because it works with property names
            rather than positions. This makes it more flexible and less prone to errors when the order of properties
            changes. The syntax uses curly braces on the left side of an assignment, with variable names matching the
            object's property names.</p>

        <p><strong>Basic Object Destructuring:</strong></p>

        <pre><code class="language-javascript">const user = {
    name: 'John',
    age: 30,
    email: 'john@example.com'
};

// With destructuring
const { name, age, email } = user;
console.log(name);  // 'John'
console.log(age);   // 30
console.log(email); // 'john@example.com'
</code></pre>

        <p>Object destructuring extracts properties by name, not position. This means the order doesn't matter - you can
            destructure properties in any sequence you like. If a property doesn't exist, the variable will be
            <code>undefined</code>.
        </p>

        <p><strong>Renaming Variables:</strong></p>

        <p>One of the most useful features of object destructuring is the ability to rename variables during extraction.
            This is helpful when the property name doesn't match your preferred variable name, or when you need to avoid
            naming conflicts in your code.</p>

        <pre><code class="language-javascript">const user = {
    name: 'John',
    age: 30
};

// Rename during destructuring
const { name: userName, age: userAge } = user;
console.log(userName); // 'John'
console.log(userAge);  // 30
</code></pre>

        <p>The colon syntax <code>name: userName</code> means "take the <code>name</code> property and assign it to a
            variable called <code>userName</code>." This is the opposite of object literal shorthand, which can be
            confusing at first.</p>

        <p><strong>Default Values:</strong></p>

        <p>Destructuring supports default values, which are used when a property is <code>undefined</code> or doesn't
            exist. This is incredibly useful for handling optional properties or providing fallback values for missing
            data, especially when working with API responses or user input.</p>

        <pre><code class="language-javascript">const user = {
    name: 'John'
};

// With default values
const { name, age = 25, country = 'USA' } = user;
console.log(name);    // 'John'
console.log(age);     // 25 (default)
console.log(country); // 'USA' (default)
</code></pre>

        <p>Note that default values only apply when the property is <code>undefined</code>. If the property exists but
            has a value of <code>null</code>, <code>0</code>, or empty string, the default won't be used.</p>

        <h3>Nested Destructuring</h3>

        <p>Real-world data structures are often nested several levels deep. Destructuring can reach into nested objects
            and arrays, allowing you to extract deeply nested values in a single expression. While this is powerful, be
            careful not to make your destructuring too complex, as it can become hard to read.</p>

        <pre><code class="language-javascript">const user = {
    name: 'John',
    address: {
        street: '123 Main St',
        city: 'New York',
        coordinates: {
            lat: 40.7128,
            lng: -74.0060
        }
    }
};

// Destructure nested properties
const {
    name,
    address: {
        city,
        coordinates: { lat, lng }
    }
} = user;

console.log(name); // 'John'
console.log(city); // 'New York'
console.log(lat);  // 40.7128
</code></pre>

        <h3>Function Parameter Destructuring</h3>

        <pre><code class="language-javascript">// With destructuring
function displayUser({ name, age }) {
    console.log(`${name} is ${age} years old`);
}

displayUser({ name: 'John', age: 30 });
// "John is 30 years old"

// With default values
function createUser({ name, age = 18, role = 'user' }) {
    return { name, age, role };
}

console.log(createUser({ name: 'John' }));
// { name: 'John', age: 18, role: 'user' }
</code></pre>

        <h3>Real-World Examples</h3>

        <p><strong>API Response Handling:</strong></p>

        <pre><code class="language-javascript">async function fetchUser(id) {
    const response = await fetch(`/api/users/${id}`);
    const { data: user, status, message } = await response.json();
    
    if (status === 'success') {
        const { name, email, profile: { avatar } } = user;
        return { name, email, avatar };
    }
    
    throw new Error(message);
}
</code></pre>

        <p><strong>Array Methods:</strong></p>

        <pre><code class="language-javascript">const users = [
    { id: 1, name: 'John', age: 30 },
    { id: 2, name: 'Jane', age: 25 },
    { id: 3, name: 'Bob', age: 35 }
];

// Destructure in map
const names = users.map(({ name }) => name);
console.log(names); // ['John', 'Jane', 'Bob']

// Destructure in filter
const adults = users.filter(({ age }) => age >= 30);
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Destructuring extracts values from arrays and objects into variables</li>
            <li>Array destructuring uses square brackets <code>[]</code></li>
            <li>Object destructuring uses curly braces <code>{}</code></li>
            <li>You can provide default values for missing properties</li>
            <li>Rename variables during destructuring with <code>:</code></li>
            <li>Rest operator <code>...</code> collects remaining elements</li>
            <li>Destructuring works in function parameters for cleaner APIs</li>
            <li>Nested destructuring extracts deeply nested values</li>
        </ul>
    </div>


    <!-- Chapter 17: Spread and Rest Operators -->
    <div id="chapter17" class="page-break">
        <h1>Chapter 17: JavaScript Spread and Rest Operators</h1>
        <h2>Master Array and Object Operations</h2>

        <p>The spread (...) and rest operators use the same syntax but serve different purposes: spread expands
            elements, while rest collects them.</p>

        <p>These operators have revolutionized how we work with arrays and objects in JavaScript. They enable immutable
            data patterns, make function signatures more flexible, and provide elegant solutions to common programming
            tasks that previously required verbose workarounds.</p>

        <h3>Spread Operator with Arrays</h3>

        <p>The spread operator expands an array into its individual elements. This is incredibly useful for combining
            arrays, creating copies, and passing array elements as function arguments. Unlike methods like
            <code>concat()</code>, the spread operator is more readable and can be used in various contexts.
        </p>

        <p><strong>Copy Arrays:</strong></p>

        <pre><code class="language-javascript">const original = [1, 2, 3];
const copy = [...original];

copy.push(4);
console.log(original); // [1, 2, 3] - unchanged
console.log(copy);     // [1, 2, 3, 4]
</code></pre>

        <p><strong>Merge Arrays:</strong></p>

        <pre><code class="language-javascript">const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const merged = [...arr1, ...arr2];
console.log(merged); // [1, 2, 3, 4, 5, 6]

// Insert in middle
const combined = [...arr1, 99, ...arr2];
console.log(combined); // [1, 2, 3, 99, 4, 5, 6]
</code></pre>

        <p><strong>Math Operations:</strong></p>

        <pre><code class="language-javascript">const numbers = [5, 2, 8, 1, 9];

console.log(Math.max(...numbers)); // 9
console.log(Math.min(...numbers)); // 1
</code></pre>

        <h3>Spread Operator with Objects</h3>

        <p>Object spreading creates a shallow copy, meaning nested objects are still referenced. If you need a deep
            copy,
            you'll need to use other techniques like recursive copying or libraries like Lodash. The order matters when
            spreading objects - properties from later objects override earlier ones.</p>

        <p><strong>Copy Objects:</strong></p>

        <pre><code class="language-javascript">const original = { name: 'John', age: 30 };
const copy = { ...original };

copy.age = 31;
console.log(original.age); // 30 - unchanged
console.log(copy.age);     // 31
</code></pre>

        <p><strong>Merge Objects:</strong></p>

        <pre><code class="language-javascript">const defaults = { theme: 'light', language: 'en' };
const userPrefs = { theme: 'dark' };

const settings = { ...defaults, ...userPrefs };
console.log(settings);
// { theme: 'dark', language: 'en' }
// userPrefs overwrites defaults
</code></pre>

        <p><strong>Add/Update Properties:</strong></p>

        <pre><code class="language-javascript">const user = { name: 'John', age: 30 };

// Add property
const withEmail = { ...user, email: 'john@example.com' };

// Update property
const olderUser = { ...user, age: 31 };
</code></pre>

        <h3>Rest Parameters</h3>

        <p>Rest parameters allow functions to accept an indefinite number of arguments as an array. This is more
            flexible and readable than using the <code>arguments</code> object, which is array-like but not a true
            array. Rest parameters must always be the last parameter in a function signature.</p>

        <p><strong>Variable Number of Arguments:</strong></p>

        <pre><code class="language-javascript">function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3));       // 6
console.log(sum(1, 2, 3, 4, 5)); // 15
</code></pre>

        <p><strong>Rest with Named Parameters:</strong></p>

        <pre><code class="language-javascript">function greet(greeting, ...names) {
    return `${greeting} ${names.join(', ')}!`;
}

console.log(greet('Hello', 'John'));
// "Hello John!"

console.log(greet('Hello', 'John', 'Jane', 'Bob'));
// "Hello John, Jane, Bob!"
</code></pre>

        <p>Rest parameters give you a true array with all array methods available, unlike the old <code>arguments</code>
            object. This makes them perfect for variadic functions - functions that can accept any number of arguments.
        </p>

        <h3>Real-World Examples</h3>

        <p>The spread and rest operators shine in real-world scenarios. They enable clean, functional programming
            patterns and make common tasks much simpler.</p>

        <p><strong>Immutable Array Operations:</strong></p>

        <p>In modern JavaScript applications, especially with React and Redux, immutability is crucial. The spread
            operator makes it easy to create modified copies of arrays without mutating the originals.</p>

        <pre><code class="language-javascript">const todos = [
    { id: 1, text: 'Learn JS', done: false },
    { id: 2, text: 'Build app', done: false }
];

// Add todo
const addTodo = (todos, newTodo) => [...todos, newTodo];

// Update todo
const updateTodo = (todos, id, updates) =>
    todos.map(todo =>
        todo.id === id ? { ...todo, ...updates } : todo
    );
</code></pre>

        <p><strong>React State Updates:</strong></p>

        <pre><code class="language-javascript">// Add item to array
setItems([...items, newItem]);

// Update object
setUser({ ...user, name: 'Jane' });

// Update nested object
setUser({
    ...user,
    address: {
        ...user.address,
        city: 'Boston'
    }
});
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Spread (...) expands arrays/objects into individual elements</li>
            <li>Rest (...) collects multiple elements into an array</li>
            <li>Use spread to copy, merge, and add elements immutably</li>
            <li>Use rest for variable-length function parameters</li>
            <li>Spread creates shallow copies only</li>
            <li>Rest parameters must be last in function signature</li>
            <li>Essential for immutable data patterns in React/Redux</li>
        </ul>
    </div>

    name: 'John',
    address: {
    street: '123 Main St',
    city: 'New York'
    }
    };

    // This works
    console.log(user.address.city); // 'New York'

    // But this crashes
    const user2 = { name: 'Jane' };
    console.log(user2.address.city); // TypeError!

    // Old solution: verbose checks
    const city = user2 && user2.address && user2.address.city;
    </code></pre>

    <h3>Optional Chaining Solution</h3>

    <p>With optional chaining, you can safely access nested properties in a single, readable expression. If any part of
        the chain is <code>null</code> or <code>undefined</code>, the entire expression evaluates to
        <code>undefined</code> without throwing an error.
    </p>

    <pre><code class="language-javascript">const user = { name: 'Jane' };

// No error! Returns undefined
const city = user?.address?.city;
console.log(city); // undefined

// Works when property exists
const user2 = {
    name: 'John',
    address: { city: 'New York' }
};
console.log(user2?.address?.city); // 'New York'
</code></pre>

    <h3>Optional Method Calls</h3>

    <p>Optional chaining isn't limited to property access - it also works with method calls. This is incredibly useful
        when dealing with optional callbacks or methods that might not exist on an object.</p>

    <pre><code class="language-javascript">const user = {
    name: 'John',
    greet() {
        return `Hello, ${this.name}!`;
    }
};

// Call method if it exists
console.log(user.greet?.()); // "Hello, John!"
console.log(user.farewell?.()); // undefined (no error!)
</code></pre>

    <h3>Optional Array Access</h3>

    <pre><code class="language-javascript">const users = [
    { name: 'John', age: 30 },
    { name: 'Jane', age: 25 }
];

// Safe array access
const firstUser = users?.[0];
const thirdUser = users?.[2]; // undefined, no error

// Chain with property access
const firstName = users?.[0]?.name; // 'John'
const thirdName = users?.[2]?.name; // undefined
</code></pre>

    <h3>Nullish Coalescing (??)</h3>

    <p>The nullish coalescing operator (<code>??</code>) is the perfect companion to optional chaining. While optional
        chaining safely accesses properties, nullish coalescing provides default values when those properties are
        <code>null</code> or <code>undefined</code>. Importantly, it only treats <code>null</code> and
        <code>undefined</code> as nullish - unlike the <code>||</code> operator, which treats all falsy values
        (including <code>0</code>, <code>''</code>, and <code>false</code>) as falsy.
    </p>

    <pre><code class="language-javascript">const value = null ?? 'default';
console.log(value); // 'default'

const value2 = 0 ?? 'default';
console.log(value2); // 0 (not 'default'!)

// ?? vs ||
const count = 0;
console.log(count || 10); // 10 (wrong!)
console.log(count ?? 10); // 0 (correct!)
</code></pre>

    <h3>Combining ?. and ??</h3>

    <p>The real power comes from combining optional chaining with nullish coalescing. This pattern allows you to safely
        access nested properties and provide sensible defaults in a single, readable expression. It's become a standard
        pattern in modern JavaScript applications.</p>

    <pre><code class="language-javascript">const user = { name: 'John' };

// Get city or default
const city = user?.address?.city ?? 'Unknown';
console.log(city); // 'Unknown'

// Configuration with defaults
function createServer(config) {
    const port = config?.server?.port ?? 3000;
    const host = config?.server?.host ?? 'localhost';
    const timeout = config?.timeout ?? 5000;
    
    return { port, host, timeout };
}
</code></pre>

    <h3>Real-World Examples</h3>

    <p><strong>API Response Handling:</strong></p>

    <pre><code class="language-javascript">async function fetchUser(id) {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();
    
    // Safe access to nested properties
    const userName = data?.user?.name;
    const avatar = data?.user?.profile?.avatar;
    const firstHobby = data?.user?.hobbies?.[0];
    
    return { userName, avatar, firstHobby };
}
</code></pre>

    <p><strong>Event Handlers:</strong></p>

    <pre><code class="language-javascript">// Safe callback invocation
function processData(data, callback) {
    const result = transform(data);
    callback?.(result); // Only calls if callback exists
}

// Usage
processData(data); // No error even without callback
processData(data, (result) => console.log(result));
</code></pre>

    <h3>Key Takeaways</h3>
    <ul>
        <li>Optional chaining (?.) safely accesses nested properties</li>
        <li>Returns undefined instead of throwing errors</li>
        <li>Works with properties, methods, and array indices</li>
        <li>Nullish coalescing (??) provides default values</li>
        <li>?? only treats null/undefined as nullish (not 0, '', false)</li>
        <li>Combine ?. and ?? for safe access with defaults</li>
        <li>Perfect for API responses and optional callbacks</li>
    </ul>
    </div>


    <!-- Chapter 19: Modules -->
    <div id="chapter19" class="page-break">
        <h1>Chapter 19: JavaScript Modules</h1>
        <h2>Organize Your Code</h2>

        <p>ES6 modules revolutionized JavaScript development by providing a standardized, built-in module system. Before
            ES6, developers relied on various module patterns (CommonJS, AMD, UMD) or immediately invoked function
            expressions (IIFEs) to organize code. ES6 modules offer a clean, declarative syntax that's now supported
            natively in browsers and Node.js.</p>

        <p>Modules enable you to split your code into smaller, reusable pieces with explicit dependencies. Each module
            has its own scope, preventing global namespace pollution. Modules also enable static analysis, allowing
            tools to perform tree-shaking (removing unused code) and optimize your bundles. This leads to better code
            organization, easier testing, and improved maintainability.</p>

        <h3>Named Exports</h3>

        <p>Named exports allow you to export multiple values from a module. Each export must be explicitly named, and
            imports must use the same names (though you can rename them during import). This makes dependencies explicit
            and helps with code navigation and refactoring.</p>

        <pre><code class="language-javascript">// utils.js
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}

export class Calculator {
    multiply(a, b) {
        return a * b;
    }
}
</code></pre>

        <h3>Importing</h3>

        <pre><code class="language-javascript">// app.js
import { PI, add, Calculator } from './utils.js';

console.log(PI); // 3.14159
console.log(add(2, 3)); // 5

const calc = new Calculator();
console.log(calc.multiply(4, 5)); // 20

// Import all
import * as utils from './utils.js';
console.log(utils.PI);
console.log(utils.add(2, 3));
</code></pre>

        <h3>Default Exports</h3>

        <p>Each module can have one default export, which represents the primary value exported by the module. Default
            exports are useful when a module has a single main purpose or when you want to export a class or function as
            the module's primary interface. When importing, you can name the default export whatever you like.</p>

        <pre><code class="language-javascript">// user.js
export default class User {
    constructor(name) {
        this.name = name;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
}

// Import default
import User from './user.js';
const user = new User('John');
</code></pre>

        <h3>Mixing Default and Named Exports</h3>

        <pre><code class="language-javascript">// api.js
export default function fetchData() {
    return fetch('/api/data');
}

export const API_URL = 'https://api.example.com';
export const timeout = 5000;

// Import both
import fetchData, { API_URL, timeout } from './api.js';
</code></pre>

        <h3>Dynamic Imports</h3>

        <p>Dynamic imports allow you to load modules on demand, rather than at the start of your application. This is
            crucial for code splitting - breaking your application into smaller chunks that are loaded only when needed.
            Dynamic imports return a Promise, making them perfect for lazy loading features, routes, or heavy
            dependencies.</p>

        <p>This technique dramatically improves initial load times by reducing the amount of JavaScript that needs to be
            downloaded and parsed upfront. It's especially valuable for large applications where users might never
            access certain features.</p>

        <pre><code class="language-javascript">// Load modules on demand
button.addEventListener('click', async () => {
    const module = await import('./heavy.js');
    module.heavyFunction();
});

// Conditional loading
if (userIsAdmin) {
    const adminModule = await import('./admin.js');
    adminModule.init();
}

// Lazy loading routes
const routes = {
    '/home': () => import('./pages/home.js'),
    '/about': () => import('./pages/about.js')
};

async function loadRoute(path) {
    const module = await routes[path]();
    module.render();
}
</code></pre>

        <h3>Real-World Example: API Service</h3>

        <pre><code class="language-javascript">// services/api.js
const BASE_URL = 'https://api.example.com';

async function request(endpoint, options = {}) {
    const response = await fetch(`${BASE_URL}${endpoint}`, {
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        },
        ...options
    });
    
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return response.json();
}

export async function fetchUsers() {
    return request('/users');
}

export async function createUser(userData) {
    return request('/users', {
        method: 'POST',
        body: JSON.stringify(userData)
    });
}
</code></pre>

        <h3>Using Modules in HTML</h3>

        <pre><code class="language-html">&lt;!-- Modern browsers --&gt;
&lt;script type="module" src="app.js"&gt;&lt;/script&gt;

&lt;!-- Inline module --&gt;
&lt;script type="module"&gt;
    import { greet } from './utils.js';
    greet('World');
&lt;/script&gt;
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>ES6 modules provide standardized code organization</li>
            <li>Use named exports for multiple exports</li>
            <li>Use default export for main export (one per module)</li>
            <li>Dynamic imports enable code splitting and lazy loading</li>
            <li>Modules are strict mode by default</li>
            <li>Imports are read-only live bindings</li>
            <li>Better tree-shaking than CommonJS</li>
            <li>Use <code>type="module"</code> in HTML script tags</li>
        </ul>
    </div>


    <!-- PART VI -->
    <div class="page-break">
        <h1 class="center">Part VI</h1>
        <h2 class="center">Browser APIs and DOM</h2>
    </div>

    <!-- Chapter 20: DOM Manipulation -->
    <div id="chapter20" class="page-break">
        <h1>Chapter 20: JavaScript DOM Manipulation</h1>
        <h2>Control the Document Structure</h2>

        <p>The Document Object Model (DOM) is the programming interface for HTML documents. It represents the page as a
            tree of objects that JavaScript can manipulate. DOM manipulation is the foundation of dynamic web pages,
            allowing you to create, modify, and delete elements in response to user actions or data changes.</p>

        <p>Modern DOM APIs provide powerful methods for selecting, creating, and modifying elements. Understanding these
            APIs is essential for building interactive web applications, whether you're working with vanilla JavaScript
            or frameworks like React and Vue.</p>

        <h3>Selecting Elements</h3>

        <pre><code class="language-javascript">// By ID
const header = document.getElementById('header');

// By CSS selector (first match)
const button = document.querySelector('.btn-primary');
const firstItem = document.querySelector('#list > li:first-child');

// By CSS selector (all matches)
const items = document.querySelectorAll('.list-item');
items.forEach(item => console.log(item));

// Modern approach - use querySelector/querySelectorAll
const nav = document.querySelector('nav.navbar');
const links = document.querySelectorAll('a[href^="http"]');
</code></pre>

        <h3>Creating Elements</h3>

        <pre><code class="language-javascript">// Create element
const div = document.createElement('div');

// Set attributes
div.className = 'container';
div.id = 'main-container';
div.setAttribute('data-id', '123');

// Set content
div.textContent = 'Hello World'; // Text only
div.innerHTML = '<p>Hello <strong>World</strong></p>'; // HTML

// Append to DOM
document.body.appendChild(div);
</code></pre>

        <h3>Modifying Elements</h3>

        <pre><code class="language-javascript">const element = document.querySelector('#myElement');

// Change content
element.textContent = 'New text content';

// Change attributes
element.setAttribute('data-id', '123');
element.id = 'newId';

// Change styles with CSS classes (preferred)
element.classList.add('active');
element.classList.remove('hidden');
element.classList.toggle('visible');
element.classList.contains('active'); // true/false
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Use querySelector/querySelectorAll for flexible selection</li>
            <li>createElement creates new DOM elements</li>
            <li>classList methods manage CSS classes efficiently</li>
            <li>textContent is safer than innerHTML</li>
            <li>appendChild adds elements to the DOM</li>
            <li>remove() deletes elements from the DOM</li>
        </ul>
    </div>


    <!-- Chapter 21: Event Handling -->
    <div id="chapter21" class="page-break">
        <h1>Chapter 21: JavaScript Event Handling</h1>
        <h2>Respond to User Interactions</h2>

        <p>Event handling is the mechanism that makes web pages interactive. Events are actions or occurrences that
            happen in the browser - user clicks, keyboard input, page loading, form submissions, and more. JavaScript
            can listen for these events and execute code in response, creating dynamic, responsive user experiences.</p>

        <p>The modern event system uses <code>addEventListener</code>, which allows multiple handlers for the same event
            and provides fine-grained control over event propagation. Understanding event bubbling, capturing, and
            delegation is crucial for building efficient, maintainable applications.</p>

        <h3>Adding Event Listeners</h3>

        <p>Event listeners attach functions to elements that execute when specific events occur. The
            <code>addEventListener</code> method is the standard way to register event handlers, offering more
            flexibility than inline event attributes.
        </p>

        <pre><code class="language-javascript">const button = document.querySelector('#myButton');

// Click event
button.addEventListener('click', (event) => {
    console.log('Button clicked!');
    console.log('Event:', event);
});

// Multiple events
const input = document.querySelector('#myInput');
input.addEventListener('focus', () => console.log('Focused'));
input.addEventListener('blur', () => console.log('Blurred'));
input.addEventListener('input', (e) => console.log('Value:', e.target.value));
</code></pre>

        <h3>Event Delegation</h3>

        <pre><code class="language-javascript">// Instead of adding listeners to each item
const list = document.querySelector('#todoList');

list.addEventListener('click', (event) => {
    if (event.target.matches('.delete-btn')) {
        event.target.closest('li').remove();
    }
    
    if (event.target.matches('.checkbox')) {
        event.target.closest('li').classList.toggle('completed');
    }
});
</code></pre>

        <h3>Preventing Default Behavior</h3>

        <pre><code class="language-javascript">const form = document.querySelector('#myForm');

form.addEventListener('submit', (event) => {
    event.preventDefault(); // Stop form submission
    
    const formData = new FormData(form);
    const data = Object.fromEntries(formData);
    console.log('Form data:', data);
});

const link = document.querySelector('a');
link.addEventListener('click', (event) => {
    event.preventDefault(); // Stop navigation
    console.log('Link clicked but not followed');
});
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>addEventListener attaches event handlers</li>
            <li>Event delegation improves performance for dynamic content</li>
            <li>event.preventDefault() stops default browser behavior</li>
            <li>event.stopPropagation() stops event bubbling</li>
            <li>Use event.target to identify the clicked element</li>
            <li>Remove listeners with removeEventListener</li>
        </ul>
    </div>


    <!-- Chapter 23: LocalStorage -->
    <div id="chapter22" class="page-break">
        <h1>Chapter 22: JavaScript LocalStorage</h1>
        <h2>Browser Data Persistence</h2>

        <p>LocalStorage is a web storage API that allows you to store data in the browser that persists even after the
            browser is closed. Unlike cookies, which are sent with every HTTP request, localStorage data stays in the
            browser and is only accessible via JavaScript. This makes it perfect for storing user preferences, cached
            data, or application state.</p>

        <p>LocalStorage provides a simple key-value interface with a storage limit of about 5-10MB per domain (varies by
            browser). Data is stored as strings, so you need to serialize objects using JSON. While convenient,
            localStorage is synchronous and can block the main thread, so it's not suitable for large amounts of data or
            performance-critical operations.</p>

        <h3>Basic Operations</h3>

        <p>LocalStorage provides four main methods: <code>setItem()</code>, <code>getItem()</code>,
            <code>removeItem()</code>, and <code>clear()</code>. These methods provide a simple interface for storing
            and retrieving data.
        </p>

        <pre><code class="language-javascript">// Store data
localStorage.setItem('username', 'John');
localStorage.setItem('theme', 'dark');

// Retrieve data
const username = localStorage.getItem('username');
console.log(username); // 'John'

// Remove data
localStorage.removeItem('theme');

// Clear all data
localStorage.clear();

// Check if key exists
if (localStorage.getItem('username')) {
    console.log('Username exists');
}
</code></pre>

        <h3>Storing Objects</h3>

        <pre><code class="language-javascript">// Store object (must stringify)
const user = {
    name: 'John',
    email: 'john@example.com',
    preferences: { theme: 'dark' }
};

localStorage.setItem('user', JSON.stringify(user));

// Retrieve object (must parse)
const storedUser = JSON.parse(localStorage.getItem('user'));
console.log(storedUser.name); // 'John'
</code></pre>

        <h3>Helper Functions</h3>

        <pre><code class="language-javascript">const storage = {
    set(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
    },
    
    get(key, defaultValue = null) {
        const item = localStorage.getItem(key);
        return item ? JSON.parse(item) : defaultValue;
    },
    
    remove(key) {
        localStorage.removeItem(key);
    },
    
    clear() {
        localStorage.clear();
    }
};

// Usage
storage.set('settings', { theme: 'dark', lang: 'en' });
const settings = storage.get('settings', { theme: 'light' });
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>LocalStorage stores data as strings</li>
            <li>Data persists across browser sessions</li>
            <li>Use JSON.stringify/parse for objects</li>
            <li>5-10MB storage limit per domain</li>
            <li>Synchronous API (blocks main thread)</li>
            <li>Only accessible from same origin</li>
        </ul>
    </div>


    <!-- Chapter 22: Fetch API -->
    <div id="chapter22" class="page-break">
        <h1>Chapter 23: JavaScript Fetch API</h1>
        <h2>Modern HTTP Requests</h2>

        <p>The Fetch API is the modern standard for making HTTP requests in JavaScript. It replaces the older
            XMLHttpRequest with a cleaner, promise-based interface that works seamlessly with async/await. Fetch is
            built into all modern browsers and provides a powerful, flexible way to communicate with servers.</p>

        <p>Unlike XMLHttpRequest, Fetch uses Promises natively, making it easier to handle asynchronous operations and
            avoid callback hell. It provides a more intuitive API for setting headers, handling different response
            types, and managing request/response streams. However, it's important to note that Fetch doesn't reject on
            HTTP error statuses - you need to check <code>response.ok</code> explicitly.</p>

        <h3>Basic GET Request</h3>

        <p>The simplest Fetch request is a GET request to retrieve data from a server. Fetch returns a Promise that
            resolves to a Response object, which you then parse to extract the data.</p>

        <pre><code class="language-javascript">// Simple GET request
fetch('https://api.example.com/users')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));

// With async/await
async function getUsers() {
    try {
        const response = await fetch('https://api.example.com/users');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error:', error);
    }
}
</code></pre>

        <h3>POST Request</h3>

        <pre><code class="language-javascript">async function createUser(userData) {
    const response = await fetch('https://api.example.com/users', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(userData)
    });
    
    return await response.json();
}

// Usage
const newUser = await createUser({
    name: 'John Doe',
    email: 'john@example.com'
});
</code></pre>

        <h3>Error Handling</h3>

        <pre><code class="language-javascript">async function fetchWithErrorHandling(url) {
    try {
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        return data;
    } catch (error) {
        if (error.name === 'TypeError') {
            console.error('Network error:', error);
        } else {
            console.error('Error:', error);
        }
        throw error;
    }
}
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Fetch returns a Promise that resolves to Response</li>
            <li>Use response.json() to parse JSON data</li>
            <li>Check response.ok for successful responses</li>
            <li>Set method, headers, and body for different request types</li>
            <li>Always handle errors with try/catch</li>
            <li>Fetch doesn't reject on HTTP errors (404, 500, etc.)</li>
        </ul>
    </div>


    <!-- Chapter 24: IntersectionObserver -->
    <div id="chapter24" class="page-break">
        <h1>Chapter 24: JavaScript IntersectionObserver</h1>
        <h2>Efficient Visibility Detection</h2>

        <p>IntersectionObserver is a powerful browser API that asynchronously observes changes in the intersection of a
            target element with an ancestor element or the viewport. It solves the performance problems of scroll event
            listeners by providing an efficient, non-blocking way to detect when elements become visible or hidden.</p>

        <p>Before IntersectionObserver, detecting element visibility required scroll event listeners that repeatedly
            called expensive methods like <code>getBoundingClientRect()</code>. IntersectionObserver handles this
            efficiently in the browser's rendering pipeline, making it perfect for lazy loading images, infinite scroll,
            analytics tracking, and animation triggers.</p>

        <h3>Basic Usage</h3>

        <p>IntersectionObserver takes a callback function that's called whenever observed elements intersect with the
            viewport (or a specified ancestor). The callback receives an array of intersection entries describing what
            changed.</p>

        <pre><code class="language-javascript">// Create observer
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            console.log('Element is visible:', entry.target);
            entry.target.classList.add('visible');
        }
    });
});

// Observe elements
const elements = document.querySelectorAll('.lazy-load');
elements.forEach(el => observer.observe(el));
</code></pre>

        <h3>Lazy Loading Images</h3>

        <pre><code class="language-javascript">const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.classList.add('loaded');
            imageObserver.unobserve(img);
        }
    });
});

const images = document.querySelectorAll('img[data-src]');
images.forEach(img => imageObserver.observe(img));
</code></pre>

        <h3>Infinite Scroll</h3>

        <pre><code class="language-javascript">const sentinel = document.querySelector('#sentinel');

const scrollObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            loadMoreContent();
        }
    });
}, {
    rootMargin: '100px' // Load before reaching bottom
});

scrollObserver.observe(sentinel);

async function loadMoreContent() {
    const data = await fetchMoreData();
    renderData(data);
}
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>IntersectionObserver is more efficient than scroll events</li>
            <li>Perfect for lazy loading images and content</li>
            <li>Use rootMargin to trigger before element is visible</li>
            <li>unobserve() stops watching an element</li>
            <li>Asynchronous and non-blocking</li>
            <li>Great for infinite scroll implementations</li>
        </ul>
    </div>



    <!-- PART VII -->
    <div class="page-break">
        <h1 class="center">Part VII</h1>
        <h2 class="center">Algorithms and Data Structures</h2>
    </div>

    <!-- Chapter 25: Arrays and Array Methods -->
    <div id="chapter25" class="page-break">
        <h1>Chapter 25: JavaScript Arrays and Array Methods</h1>
        <h2>Master Array Manipulation</h2>

        <p>Arrays are one of the most fundamental data structures in JavaScript. Understanding array methods and
            manipulation techniques is essential for writing efficient, readable code. JavaScript provides a rich set of
            built-in array methods that enable functional programming patterns and make data transformation elegant.</p>

        <h3>Common Array Methods</h3>

        <pre><code class="language-javascript">// Transformation
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2); // [2, 4, 6, 8, 10]

// Filtering
const evens = numbers.filter(n => n % 2 === 0); // [2, 4]

// Reduction
const sum = numbers.reduce((acc, n) => acc + n, 0); // 15

// Finding
const firstEven = numbers.find(n => n % 2 === 0); // 2
const hasNegative = numbers.some(n => n < 0); // false
const allPositive = numbers.every(n => n > 0); // true</code></pre>

        <h3>Array Iteration</h3>

        <pre><code class="language-javascript">const fruits = ['apple', 'banana', 'orange'];

// forEach - side effects
fruits.forEach((fruit, index) => {
    console.log(`${index}: ${fruit}`);
});

// for...of - modern iteration
for (const fruit of fruits) {
    console.log(fruit);
}

// Traditional for loop - when you need index control
for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
}</code></pre>

        <h3>Array Manipulation</h3>

        <pre><code class="language-javascript">const arr = [1, 2, 3];

// Adding elements
arr.push(4);        // Add to end: [1, 2, 3, 4]
arr.unshift(0);     // Add to start: [0, 1, 2, 3, 4]

// Removing elements
arr.pop();          // Remove from end: [0, 1, 2, 3]
arr.shift();        // Remove from start: [1, 2, 3]

// Immutable alternatives
const withAdded = [...arr, 4];           // [1, 2, 3, 4]
const withRemoved = arr.slice(0, -1);    // [1, 2]</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Use <code>map()</code>, <code>filter()</code>, <code>reduce()</code> for transformations</li>
            <li>Prefer immutable methods for predictable code</li>
            <li><code>find()</code> and <code>findIndex()</code> for searching</li>
            <li><code>some()</code> and <code>every()</code> for validation</li>
            <li>Spread operator for immutable operations</li>
        </ul>
    </div>

    <!-- Chapter 26: Stacks and Queues -->
    <div id="chapter26" class="page-break">
        <h1>Chapter 26: JavaScript Stacks and Queues</h1>
        <h2>LIFO and FIFO Data Structures</h2>

        <p>Stacks and queues are fundamental data structures that control the order of element access. Stacks follow
            Last-In-First-Out (LIFO), while queues follow First-In-First-Out (FIFO). Both are essential for algorithms,
            browser history, undo/redo functionality, and task scheduling.</p>

        <h3>Stack Implementation</h3>

        <pre><code class="language-javascript">class Stack {
    constructor() {
        this.items = [];
    }

    push(element) {
        this.items.push(element);
    }

    pop() {
        if (this.isEmpty()) return null;
        return this.items.pop();
    }

    peek() {
        if (this.isEmpty()) return null;
        return this.items[this.items.length - 1];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }
}

// Usage
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack.pop());  // 3 (LIFO)
console.log(stack.peek()); // 2</code></pre>

        <h3>Queue Implementation</h3>

        <pre><code class="language-javascript">class Queue {
    constructor() {
        this.items = [];
    }

    enqueue(element) {
        this.items.push(element);
    }

    dequeue() {
        if (this.isEmpty()) return null;
        return this.items.shift();
    }

    front() {
        if (this.isEmpty()) return null;
        return this.items[0];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }
}

// Usage
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
console.log(queue.dequeue()); // 1 (FIFO)
console.log(queue.front());   // 2</code></pre>

        <h3>Real-World Applications</h3>

        <pre><code class="language-javascript">// Undo/Redo with Stacks
class UndoManager {
    constructor() {
        this.undoStack = new Stack();
        this.redoStack = new Stack();
    }

    execute(action) {
        action.execute();
        this.undoStack.push(action);
        this.redoStack = new Stack(); // Clear redo
    }

    undo() {
        const action = this.undoStack.pop();
        if (action) {
            action.undo();
            this.redoStack.push(action);
        }
    }

    redo() {
        const action = this.redoStack.pop();
        if (action) {
            action.execute();
            this.undoStack.push(action);
        }
    }
}</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Stack: LIFO - last in, first out</li>
            <li>Queue: FIFO - first in, first out</li>
            <li>Use stacks for undo/redo, backtracking, parsing</li>
            <li>Use queues for task scheduling, breadth-first search</li>
            <li>Both have O(1) insertion and removal</li>
        </ul>
    </div>

    <!-- Chapter 27: Linked Lists -->
    <div id="chapter27" class="page-break">
        <h1>Chapter 27: JavaScript Linked Lists</h1>
        <h2>Dynamic Data Structures</h2>

        <p>Linked lists are dynamic data structures where elements (nodes) are connected via pointers. Unlike arrays,
            linked lists don't require contiguous memory and allow efficient insertion/deletion at any position. They're
            fundamental for understanding more complex data structures.</p>

        <h3>Singly Linked List</h3>

        <pre><code class="language-javascript">class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }

    // Add to end
    append(data) {
        const newNode = new Node(data);
        
        if (!this.head) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
        this.size++;
    }

    // Add to beginning
    prepend(data) {
        const newNode = new Node(data);
        newNode.next = this.head;
        this.head = newNode;
        this.size++;
    }

    // Remove by value
    remove(data) {
        if (!this.head) return null;

        if (this.head.data === data) {
            this.head = this.head.next;
            this.size--;
            return;
        }

        let current = this.head;
        while (current.next) {
            if (current.next.data === data) {
                current.next = current.next.next;
                this.size--;
                return;
            }
            current = current.next;
        }
    }

    // Find node
    find(data) {
        let current = this.head;
        while (current) {
            if (current.data === data) return current;
            current = current.next;
        }
        return null;
    }

    // Print list
    print() {
        const values = [];
        let current = this.head;
        while (current) {
            values.push(current.data);
            current = current.next;
        }
        console.log(values.join(' -> '));
    }
}

// Usage
const list = new LinkedList();
list.append(1);
list.append(2);
list.append(3);
list.prepend(0);
list.print(); // 0 -> 1 -> 2 -> 3</code></pre>

        <h3>Advantages vs Arrays</h3>
        <ul>
            <li><strong>Dynamic size</strong> - No need to specify size upfront</li>
            <li><strong>Efficient insertion/deletion</strong> - O(1) at beginning</li>
            <li><strong>No memory waste</strong> - Only allocates what's needed</li>
        </ul>

        <h3>Disadvantages vs Arrays</h3>
        <ul>
            <li><strong>No random access</strong> - Must traverse from head</li>
            <li><strong>Extra memory</strong> - Stores pointers</li>
            <li><strong>Not cache-friendly</strong> - Nodes scattered in memory</li>
        </ul>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Linked lists use nodes connected by pointers</li>
            <li>O(1) insertion/deletion at head</li>
            <li>O(n) search and access</li>
            <li>Good for frequent insertions/deletions</li>
            <li>Poor for random access</li>
        </ul>
    </div>

    <!-- Chapter 28: Trees and Binary Search Trees -->
    <div id="chapter28" class="page-break">
        <h1>Chapter 28: JavaScript Trees and Binary Search Trees</h1>
        <h2>Hierarchical Data Structures</h2>

        <p>Trees are hierarchical data structures with a root node and child nodes. Binary Search Trees (BST) are a
            special type where each node has at most two children, and the left child is smaller while the right child
            is larger. BSTs enable efficient searching, insertion, and deletion.</p>

        <h3>Binary Search Tree Implementation</h3>

        <pre><code class="language-javascript">class TreeNode {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

class BinarySearchTree {
    constructor() {
        this.root = null;
    }

    insert(value) {
        const newNode = new TreeNode(value);
        
        if (!this.root) {
            this.root = newNode;
            return;
        }

        let current = this.root;
        while (true) {
            if (value < current.value) {
                if (!current.left) {
                    current.left = newNode;
                    return;
                }
                current = current.left;
            } else {
                if (!current.right) {
                    current.right = newNode;
                    return;
                }
                current = current.right;
            }
        }
    }

    search(value) {
        let current = this.root;
        while (current) {
            if (value === current.value) return true;
            if (value < current.value) {
                current = current.left;
            } else {
                current = current.right;
            }
        }
        return false;
    }

    // In-order traversal (sorted order)
    inOrder(node = this.root, result = []) {
        if (node) {
            this.inOrder(node.left, result);
            result.push(node.value);
            this.inOrder(node.right, result);
        }
        return result;
    }

    // Pre-order traversal
    preOrder(node = this.root, result = []) {
        if (node) {
            result.push(node.value);
            this.preOrder(node.left, result);
            this.preOrder(node.right, result);
        }
        return result;
    }

    // Post-order traversal
    postOrder(node = this.root, result = []) {
        if (node) {
            this.postOrder(node.left, result);
            this.postOrder(node.right, result);
            result.push(node.value);
        }
        return result;
    }
}

// Usage
const bst = new BinarySearchTree();
bst.insert(50);
bst.insert(30);
bst.insert(70);
bst.insert(20);
bst.insert(40);
bst.insert(60);
bst.insert(80);

console.log(bst.search(40));     // true
console.log(bst.inOrder());      // [20, 30, 40, 50, 60, 70, 80]</code></pre>

        <h3>Tree Traversal Methods</h3>
        <ul>
            <li><strong>In-order</strong> - Left, Root, Right (sorted for BST)</li>
            <li><strong>Pre-order</strong> - Root, Left, Right (copy tree)</li>
            <li><strong>Post-order</strong> - Left, Right, Root (delete tree)</li>
            <li><strong>Level-order</strong> - Breadth-first (use queue)</li>
        </ul>

        <h3>Key Takeaways</h3>
        <ul>
            <li>BST maintains sorted order</li>
            <li>Average O(log n) search, insert, delete</li>
            <li>Worst case O(n) if unbalanced</li>
            <li>In-order traversal gives sorted output</li>
            <li>Used in databases, file systems, autocomplete</li>
        </ul>
    </div>

    <!-- Chapter 29: Hash Tables and Maps -->
    <div id="chapter29" class="page-break">
        <h1>Chapter 29: JavaScript Hash Tables and Maps</h1>
        <h2>Fast Key-Value Storage</h2>

        <p>Hash tables provide O(1) average-case lookup, insertion, and deletion by using a hash function to map keys to
            array indices. JavaScript's Map and Object are built on hash table concepts, offering efficient key-value
            storage.</p>

        <h3>JavaScript Map</h3>

        <pre><code class="language-javascript">// Map - modern key-value storage
const map = new Map();

// Set values
map.set('name', 'Alice');
map.set('age', 30);
map.set(1, 'number key');
map.set({id: 1}, 'object key');

// Get values
console.log(map.get('name')); // 'Alice'

// Check existence
console.log(map.has('age')); // true

// Delete
map.delete('age');

// Iterate
for (const [key, value] of map) {
    console.log(`${key}: ${value}`);
}

// Size
console.log(map.size); // 3</code></pre>

        <h3>Simple Hash Table Implementation</h3>

        <pre><code class="language-javascript">class HashTable {
    constructor(size = 53) {
        this.keyMap = new Array(size);
    }

    _hash(key) {
        let total = 0;
        const PRIME = 31;
        for (let i = 0; i < Math.min(key.length, 100); i++) {
            const char = key[i];
            const value = char.charCodeAt(0) - 96;
            total = (total * PRIME + value) % this.keyMap.length;
        }
        return total;
    }

    set(key, value) {
        const index = this._hash(key);
        if (!this.keyMap[index]) {
            this.keyMap[index] = [];
        }
        // Handle collisions with chaining
        this.keyMap[index].push([key, value]);
    }

    get(key) {
        const index = this._hash(key);
        if (this.keyMap[index]) {
            for (const [k, v] of this.keyMap[index]) {
                if (k === key) return v;
            }
        }
        return undefined;
    }

    keys() {
        const keys = [];
        for (const bucket of this.keyMap) {
            if (bucket) {
                for (const [key] of bucket) {
                    keys.push(key);
                }
            }
        }
        return keys;
    }

    values() {
        const values = [];
        for (const bucket of this.keyMap) {
            if (bucket) {
                for (const [, value] of bucket) {
                    if (!values.includes(value)) {
                        values.push(value);
                    }
                }
            }
        }
        return values;
    }
}

// Usage
const ht = new HashTable();
ht.set('hello', 'world');
ht.set('foo', 'bar');
console.log(ht.get('hello')); // 'world'</code></pre>

        <h3>Map vs Object</h3>
        <ul>
            <li><strong>Map</strong> - Any type as key, maintains insertion order, has size property</li>
            <li><strong>Object</strong> - String/Symbol keys only, no guaranteed order, no size property</li>
            <li>Use Map for frequent additions/deletions</li>
            <li>Use Object for simple key-value pairs</li>
        </ul>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Hash tables provide O(1) average lookup</li>
            <li>Hash function converts keys to indices</li>
            <li>Collisions handled by chaining or open addressing</li>
            <li>Map is preferred over Object for dynamic data</li>
            <li>Essential for caching, indexing, counting</li>
        </ul>
    </div>

    <!-- Chapter 30: Sorting Algorithms -->
    <div id="chapter30" class="page-break">
        <h1>Chapter 30: JavaScript Sorting Algorithms</h1>
        <h2>Organize Data Efficiently</h2>

        <p>Sorting algorithms arrange data in a specific order. Understanding different sorting algorithms helps you
            choose the right one for your use case and appreciate the built-in <code>Array.sort()</code> method.</p>

        <h3>Bubble Sort - O(nÂ²)</h3>

        <pre><code class="language-javascript">function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}

console.log(bubbleSort([64, 34, 25, 12, 22]));
// [12, 22, 25, 34, 64]</code></pre>

        <h3>Quick Sort - O(n log n) average</h3>

        <pre><code class="language-javascript">function quickSort(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[arr.length - 1];
    const left = [];
    const right = [];
    
    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    
    return [...quickSort(left), pivot, ...quickSort(right)];
}

console.log(quickSort([64, 34, 25, 12, 22]));
// [12, 22, 25, 34, 64]</code></pre>

        <h3>Merge Sort - O(n log n)</h3>

        <pre><code class="language-javascript">function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return result.concat(left.slice(i)).concat(right.slice(j));
}

console.log(mergeSort([64, 34, 25, 12, 22]));
// [12, 22, 25, 34, 64]</code></pre>

        <h3>Built-in Array.sort()</h3>

        <pre><code class="language-javascript">// Default (converts to strings)
const nums = [10, 5, 40, 25, 1000, 1];
nums.sort(); // [1, 10, 1000, 25, 40, 5] - WRONG!

// Correct numeric sort
nums.sort((a, b) => a - b); // [1, 5, 10, 25, 40, 1000]

// Descending
nums.sort((a, b) => b - a); // [1000, 40, 25, 10, 5, 1]

// Sort objects
const users = [
    {name: 'Bob', age: 30},
    {name: 'Alice', age: 25},
    {name: 'Charlie', age: 35}
];
users.sort((a, b) => a.age - b.age);
// [{name: 'Alice', age: 25}, {name: 'Bob', age: 30}, {name: 'Charlie', age: 35}]</code></pre>

        <h3>Algorithm Comparison</h3>
        <ul>
            <li><strong>Bubble Sort</strong> - O(nÂ²), simple but slow</li>
            <li><strong>Quick Sort</strong> - O(n log n) average, fast in practice</li>
            <li><strong>Merge Sort</strong> - O(n log n) guaranteed, stable</li>
            <li><strong>Array.sort()</strong> - Usually Timsort (hybrid), O(n log n)</li>
        </ul>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Use built-in <code>Array.sort()</code> for most cases</li>
            <li>Always provide comparator for numeric sorting</li>
            <li>Understand time complexity: O(nÂ²) vs O(n log n)</li>
            <li>Merge sort is stable (preserves order of equal elements)</li>
            <li>Quick sort is fast but not stable</li>
        </ul>
    </div>

    <!-- Chapter 31: Searching Algorithms -->
    <div id="chapter31" class="page-break">
        <h1>Chapter 31: JavaScript Searching Algorithms</h1>
        <h2>Find Data Efficiently</h2>

        <p>Searching algorithms find specific elements in data structures. Understanding different search strategies
            helps you write efficient code and choose the right approach for your data.</p>

        <h3>Linear Search - O(n)</h3>

        <pre><code class="language-javascript">function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Return index
        }
    }
    return -1; // Not found
}

const arr = [5, 2, 8, 1, 9];
console.log(linearSearch(arr, 8)); // 2
console.log(linearSearch(arr, 7)); // -1</code></pre>

        <h3>Binary Search - O(log n)</h3>

        <pre><code class="language-javascript">// Requires sorted array
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

const sorted = [1, 2, 5, 8, 9];
console.log(binarySearch(sorted, 8)); // 3
console.log(binarySearch(sorted, 7)); // -1</code></pre>

        <h3>Binary Search (Recursive)</h3>

        <pre><code class="language-javascript">function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
    if (left > right) return -1;
    
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}

console.log(binarySearchRecursive([1, 2, 5, 8, 9], 8)); // 3</code></pre>

        <h3>Built-in Array Methods</h3>

        <pre><code class="language-javascript">const arr = [1, 2, 3, 4, 5];

// indexOf - linear search
console.log(arr.indexOf(3));        // 2
console.log(arr.indexOf(10));       // -1

// includes - linear search (returns boolean)
console.log(arr.includes(3));       // true
console.log(arr.includes(10));      // false

// find - linear search (returns element)
const users = [
    {id: 1, name: 'Alice'},
    {id: 2, name: 'Bob'},
    {id: 3, name: 'Charlie'}
];
const user = users.find(u => u.id === 2);
console.log(user); // {id: 2, name: 'Bob'}

// findIndex - linear search (returns index)
const index = users.findIndex(u => u.name === 'Charlie');
console.log(index); // 2</code></pre>

        <h3>When to Use Each</h3>
        <ul>
            <li><strong>Linear Search</strong> - Unsorted data, small arrays</li>
            <li><strong>Binary Search</strong> - Sorted data, large arrays</li>
            <li><strong>indexOf/includes</strong> - Simple value search</li>
            <li><strong>find/findIndex</strong> - Complex conditions, objects</li>
        </ul>

        <h3>Search Optimization</h3>

        <pre><code class="language-javascript">// Bad - O(nÂ²) - searching in loop
function findPairs(arr, target) {
    const pairs = [];
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] + arr[j] === target) {
                pairs.push([arr[i], arr[j]]);
            }
        }
    }
    return pairs;
}

// Good - O(n) - using hash table
function findPairsOptimized(arr, target) {
    const pairs = [];
    const seen = new Set();
    
    for (const num of arr) {
        const complement = target - num;
        if (seen.has(complement)) {
            pairs.push([complement, num]);
        }
        seen.add(num);
    }
    
    return pairs;
}

console.log(findPairsOptimized([1, 2, 3, 4, 5], 6));
// [[1, 5], [2, 4]]</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Linear search: O(n), works on any array</li>
            <li>Binary search: O(log n), requires sorted array</li>
            <li>Use built-in methods for simple searches</li>
            <li>Hash tables can optimize search to O(1)</li>
            <li>Choose algorithm based on data characteristics</li>
        </ul>
    </div>

    <!-- PART VIII -->
    <div class="page-break">
        <h1 class="center">Part VII</h1>
        <h2 class="center">Design Patterns</h2>
    </div>

    <!-- Chapter 32: Singleton Pattern -->
    <div id="chapter32" class="page-break">
        <h1>Chapter 32: JavaScript Singleton Pattern</h1>
        <h2>One Instance to Rule Them All</h2>

        <p>The Singleton pattern is one of the most widely used design patterns in software development. It ensures that
            a class has only one instance throughout the application's lifetime and provides a global point of access to
            that instance. This is particularly useful for managing shared resources like database connections,
            configuration settings, or logging services.</p>

        <p>In JavaScript, the Singleton pattern prevents multiple instantiations of a class, which could lead to
            inconsistent state or resource conflicts. While global variables can achieve similar goals, Singletons
            provide better encapsulation and control over when the instance is created. However, they should be used
            judiciously, as they can make testing more difficult and introduce hidden dependencies.</p>

        <h3>Basic Implementation</h3>

        <p>The classic Singleton implementation checks if an instance already exists before creating a new one. If an
            instance exists, it returns that instance instead of creating a new one.</p>

        <pre><code class="language-javascript">class Database {
    constructor() {
        if (Database.instance) {
            return Database.instance;
        }
        
        this.connection = null;
        Database.instance = this;
    }
    
    connect(url) {
        if (!this.connection) {
            this.connection = { url, connected: true };
            console.log(`Connected to ${url}`);
        }
    }
    
    query(sql) {
        if (!this.connection) {
            throw new Error('Not connected');
        }
        return `Executing: ${sql}`;
    }
}

// Always returns the same instance
const db1 = new Database();
const db2 = new Database();
console.log(db1 === db2); // true
</code></pre>

        <h3>ES6 Module Singleton</h3>

        <p>The simplest and most modern way to create a Singleton in JavaScript is to leverage ES6 modules. Since
            modules are cached after the first import, exporting a single instance ensures that all imports receive the
            same object. This approach is cleaner and more idiomatic than the class-based approach.</p>

        <pre><code class="language-javascript">// database.js
class Database {
    constructor() {
        this.connection = null;
    }
    
    connect(url) {
        this.connection = { url, connected: true };
    }
}

export default new Database();

// app.js
import db from './database.js';
db.connect('mongodb://localhost');
// Every import gets the same instance!
</code></pre>

        <h3>Configuration Singleton</h3>

        <p>Configuration management is one of the most common use cases for the Singleton pattern. A configuration
            object needs to be accessible throughout your application, and you want to ensure all parts of your code are
            reading from the same configuration source.</p>

        <pre><code class="language-javascript">class Config {
    constructor() {
        if (Config.instance) {
            return Config.instance;
        }
        
        this.settings = {
            apiUrl: 'https://api.example.com',
            timeout: 5000,
            debug: false
        };
        
        Config.instance = this;
    }
    
    get(key) {
        return this.settings[key];
    }
    
    set(key, value) {
        this.settings[key] = value;
    }
}

const config = new Config();
export default config;
</code></pre>

        <h3>Logger Singleton</h3>

        <p>Logging is another perfect use case for Singletons. You want a single logger instance that collects all log
            entries in one place, making it easier to manage, filter, and export logs. This ensures consistent logging
            behavior across your entire application.</p>

        <pre><code class="language-javascript">class Logger {
    constructor() {
        if (Logger.instance) {
            return Logger.instance;
        }
        
        this.logs = [];
        Logger.instance = this;
    }
    
    log(message) {
        const entry = {
            message,
            timestamp: new Date(),
            level: 'INFO'
        };
        this.logs.push(entry);
        console.log(`[${entry.timestamp.toISOString()}] ${message}`);
    }
    
    error(message) {
        const entry = {
            message,
            timestamp: new Date(),
            level: 'ERROR'
        };
        this.logs.push(entry);
        console.error(`[${entry.timestamp.toISOString()}] ERROR: ${message}`);
    }
    
    getLogs() {
        return [...this.logs];
    }
}

export default new Logger();
</code></pre>

        <h3>Lazy Initialization</h3>

        <pre><code class="language-javascript">class HeavyResource {
    constructor() {
        console.log('Initializing heavy resource...');
        this.data = this.loadHeavyData();
    }
    
    loadHeavyData() {
        return { /* large data */ };
    }
    
    static getInstance() {
        if (!HeavyResource.instance) {
            HeavyResource.instance = new HeavyResource();
        }
        return HeavyResource.instance;
    }
}

// Not created until first use
const resource = HeavyResource.getInstance();
</code></pre>

        <h3>When to Use Singletons</h3>

        <p><strong>Good use cases:</strong></p>
        <ul>
            <li>Configuration management</li>
            <li>Logging</li>
            <li>Database connections</li>
            <li>Caching</li>
        </ul>

        <p><strong>Bad use cases:</strong></p>
        <ul>
            <li>When you need multiple instances</li>
            <li>Testing (hard to mock)</li>
            <li>When state should be isolated</li>
        </ul>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Singleton ensures only one instance exists</li>
            <li>Use ES6 modules for simple singletons</li>
            <li>Good for configuration, logging, caching</li>
            <li>Can make testing difficult</li>
            <li>Consider alternatives like dependency injection</li>
            <li>Provide reset mechanism for tests</li>
            <li>Use lazy initialization when appropriate</li>
        </ul>
    </div>


    <!-- Chapter 33: Factory Pattern -->
    <div id="chapter33" class="page-break">
        <h1>Chapter 33: JavaScript Factory Pattern</h1>
        <h2>Object Creation Made Easy</h2>

        <p>The Factory pattern is a creational design pattern that provides an interface for creating objects without
            specifying their exact classes. Instead of calling constructors directly, you call a factory function or
            method that decides which class to instantiate based on the provided parameters. This decouples object
            creation from object usage, making your code more flexible and maintainable.</p>

        <p>Factories are particularly useful when the creation process is complex, when you need to create different
            types of objects based on conditions, or when you want to hide the instantiation logic from client code.
            They promote the Open/Closed Principle - your code is open for extension but closed for modification.</p>

        <h3>Simple Factory</h3>

        <p>A simple factory uses a static method or function to create objects based on input parameters. It centralizes
            object creation logic, making it easier to manage and modify how objects are created.</p>

        <pre><code class="language-javascript">class User {
    constructor(name, role) {
        this.name = name;
        this.role = role;
    }
}

class Admin extends User {
    constructor(name) {
        super(name, 'admin');
        this.permissions = ['read', 'write', 'delete'];
    }
}

class Guest extends User {
    constructor(name) {
        super(name, 'guest');
        this.permissions = ['read'];
    }
}

class UserFactory {
    static createUser(type, name) {
        switch (type) {
            case 'admin':
                return new Admin(name);
            case 'guest':
                return new Guest(name);
            default:
                return new User(name, 'user');
        }
    }
}

// Usage
const admin = UserFactory.createUser('admin', 'John');
const guest = UserFactory.createUser('guest', 'Jane');
</code></pre>

        <h3>HTTP Client Factory</h3>

        <p>Factories are excellent for creating different implementations of the same interface. This HTTP client
            factory can create different types of HTTP clients (fetch, axios, XHR) while providing a consistent
            interface to the rest of your application.</p>

        <pre><code class="language-javascript">class HttpClientFactory {
    static create(type) {
        switch (type) {
            case 'fetch':
                return new FetchClient();
            case 'axios':
                return new AxiosClient();
            case 'xhr':
                return new XHRClient();
            default:
                return new FetchClient();
        }
    }
}

class FetchClient {
    async get(url) {
        const response = await fetch(url);
        return response.json();
    }
}
</code></pre>

        <h3>Database Connection Factory</h3>

        <pre><code class="language-javascript">class DatabaseFactory {
    static createConnection(type, config) {
        const connections = {
            mysql: () => new MySQLConnection(config),
            postgres: () => new PostgresConnection(config),
            mongodb: () => new MongoConnection(config)
        };
        
        const creator = connections[type];
        if (!creator) {
            throw new Error(`Unknown database type: ${type}`);
        }
        
        return creator();
    }
}

const db = DatabaseFactory.createConnection('postgres', {
    host: 'localhost',
    port: 5432
});
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Factory pattern encapsulates object creation</li>
            <li>Decouples creation from usage</li>
            <li>Good for complex object creation</li>
            <li>Useful for plugin systems</li>
            <li>Enables dependency injection</li>
            <li>Makes code more maintainable and testable</li>
        </ul>
    </div>


    <!-- Chapter 34: Observer Pattern -->
    <div id="chapter34" class="page-break">
        <h1>Chapter 34: JavaScript Observer Pattern</h1>
        <h2>Event-Driven Architecture</h2>

        <p>The Observer pattern, also known as the Publish-Subscribe pattern, is fundamental to event-driven
            programming. It defines a one-to-many dependency between objects: when one object (the subject) changes
            state, all its dependents (observers) are automatically notified and updated. This pattern is the foundation
            of reactive programming and is built into JavaScript through event listeners.</p>

        <p>The Observer pattern promotes loose coupling between components. The subject doesn't need to know anything
            about its observers except that they implement a specific interface. This makes it easy to add or remove
            observers without modifying the subject, following the Open/Closed Principle.</p>

        <h3>Basic Implementation</h3>

        <p>The basic Observer pattern consists of a subject that maintains a list of observers and notifies them of
            state changes. Observers register themselves with the subject and implement an update method that gets
            called when the subject's state changes.</p>

        <pre><code class="language-javascript">class Subject {
    constructor() {
        this.observers = [];
    }
    
    subscribe(observer) {
        this.observers.push(observer);
    }
    
    unsubscribe(observer) {
        this.observers = this.observers.filter(obs => obs !== observer);
    }
    
    notify(data) {
        this.observers.forEach(observer => observer.update(data));
    }
}

class Observer {
    constructor(name) {
        this.name = name;
    }
    
    update(data) {
        console.log(`${this.name} received:`, data);
    }
}

// Usage
const subject = new Subject();
const observer1 = new Observer('Observer 1');
const observer2 = new Observer('Observer 2');

subject.subscribe(observer1);
subject.subscribe(observer2);
subject.notify('Hello observers!');
</code></pre>

        <h3>Event Emitter Pattern</h3>

        <p>The Event Emitter pattern is a more flexible variation of the Observer pattern. Instead of a single update
            method, it allows observers to subscribe to specific named events. This is the pattern used by Node.js's
            EventEmitter class and the browser's DOM event system.</p>

        <pre><code class="language-javascript">class EventEmitter {
    constructor() {
        this.events = {};
    }
    
    on(event, listener) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }
    
    off(event, listener) {
        if (!this.events[event]) return;
        this.events[event] = this.events[event].filter(l => l !== listener);
    }
    
    emit(event, data) {
        if (!this.events[event]) return;
        this.events[event].forEach(listener => listener(data));
    }
}

const emitter = new EventEmitter();
emitter.on('data', (data) => console.log('Received:', data));
emitter.emit('data', { message: 'Hello' });
</code></pre>

        <h3>State Management</h3>

        <pre><code class="language-javascript">class Store {
    constructor(initialState = {}) {
        this.state = initialState;
        this.listeners = [];
    }
    
    getState() {
        return this.state;
    }
    
    setState(newState) {
        this.state = { ...this.state, ...newState };
        this.notify();
    }
    
    subscribe(listener) {
        this.listeners.push(listener);
        return () => this.unsubscribe(listener);
    }
    
    unsubscribe(listener) {
        this.listeners = this.listeners.filter(l => l !== listener);
    }
    
    notify() {
        this.listeners.forEach(listener => listener(this.state));
    }
}

const store = new Store({ count: 0 });
store.subscribe(state => console.log('State:', state));
store.setState({ count: 1 });
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Observer pattern enables event-driven architecture</li>
            <li>Subjects notify observers of state changes</li>
            <li>Promotes loose coupling</li>
            <li>Foundation of reactive programming</li>
            <li>Used in state management (Redux, MobX)</li>
            <li>Built into DOM with addEventListener</li>
        </ul>
    </div>


    <!-- Chapter 35: Builder Pattern -->
    <div id="chapter35" class="page-break">
        <h1>Chapter 35: JavaScript Builder Pattern</h1>
        <h2>Construct Complex Objects</h2>

        <p>The Builder pattern addresses the problem of constructing complex objects with many optional parameters.
            Instead of creating constructors with long parameter lists or multiple overloaded constructors, the Builder
            pattern provides a fluent interface for setting properties step by step. This makes object creation more
            readable and flexible.</p>

        <p>Builders are particularly useful when an object has many optional parameters, when the construction process
            is complex, or when you want to create immutable objects. The pattern separates the construction logic from
            the object's representation, allowing the same construction process to create different representations.</p>

        <h3>Basic Implementation</h3>

        <p>A builder typically provides methods for setting each property, with each method returning <code>this</code>
            to enable method chaining. A final <code>build()</code> method creates and returns the actual object.</p>

        <pre><code class="language-javascript">class User {
    constructor(builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
        this.address = builder.address;
    }
}

class UserBuilder {
    constructor(name) {
        this.name = name;
    }
    
    setEmail(email) {
        this.email = email;
        return this;
    }
    
    setAge(age) {
        this.age = age;
        return this;
    }
    
    setAddress(address) {
        this.address = address;
        return this;
    }
    
    build() {
        return new User(this);
    }
}

// Usage - fluent interface
const user = new UserBuilder('John')
    .setEmail('john@example.com')
    .setAge(30)
    .setAddress('123 Main St')
    .build();
</code></pre>

        <h3>Query Builder</h3>

        <pre><code class="language-javascript">class QueryBuilder {
    constructor() {
        this.query = '';
        this.params = [];
    }
    
    select(...fields) {
        this.query = `SELECT ${fields.join(', ')}`;
        return this;
    }
    
    from(table) {
        this.query += ` FROM ${table}`;
        return this;
    }
    
    where(condition, value) {
        this.query += ` WHERE ${condition}`;
        this.params.push(value);
        return this;
    }
    
    orderBy(field, direction = 'ASC') {
        this.query += ` ORDER BY ${field} ${direction}`;
        return this;
    }
    
    build() {
        return { query: this.query, params: this.params };
    }
}

const query = new QueryBuilder()
    .select('id', 'name', 'email')
    .from('users')
    .where('age > ?', 18)
    .orderBy('name')
    .build();
</code></pre>

        <h3>HTTP Request Builder</h3>

        <pre><code class="language-javascript">class RequestBuilder {
    constructor(url) {
        this.url = url;
        this.method = 'GET';
        this.headers = {};
        this.body = null;
    }
    
    setMethod(method) {
        this.method = method;
        return this;
    }
    
    setHeader(key, value) {
        this.headers[key] = value;
        return this;
    }
    
    setBody(body) {
        this.body = body;
        return this;
    }
    
    async execute() {
        return await fetch(this.url, {
            method: this.method,
            headers: this.headers,
            body: this.body ? JSON.stringify(this.body) : null
        });
    }
}

const response = await new RequestBuilder('/api/users')
    .setMethod('POST')
    .setHeader('Content-Type', 'application/json')
    .setBody({ name: 'John' })
    .execute();
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Builder pattern constructs complex objects step by step</li>
            <li>Method chaining creates fluent interfaces</li>
            <li>Each method returns <code>this</code> for chaining</li>
            <li>Perfect for objects with many optional parameters</li>
            <li>Improves code readability</li>
            <li>Common in query builders and request builders</li>
        </ul>
    </div>


    <!-- Chapter 36: Module Pattern -->
    <div id="chapter36" class="page-break">
        <h1>Chapter 36: JavaScript Module Pattern</h1>
        <h2>Encapsulation and Privacy</h2>

        <p>The Module pattern is a classic JavaScript design pattern that predates ES6 modules. It uses closures and
            immediately invoked function expressions (IIFEs) to create private scope and expose only selected
            functionality. This pattern was essential for organizing code and preventing global namespace pollution
            before modern module systems existed.</p>

        <p>While ES6 modules are now the standard, understanding the Module pattern is still valuable. It demonstrates
            how closures work, provides insights into legacy codebases, and offers an alternative approach for creating
            encapsulated components. The pattern creates a clear separation between private implementation details and
            public API.</p>

        <h3>Basic Implementation</h3>

        <p>The Module pattern wraps code in an IIFE that returns an object containing the public API. Variables and
            functions defined inside the IIFE are private and only accessible to the returned methods through closure.
        </p>

        <pre><code class="language-javascript">const Counter = (function() {
    // Private variable
    let count = 0;
    
    // Private function
    function log() {
        console.log(`Count: ${count}`);
    }
    
    // Public API
    return {
        increment() {
            count++;
            log();
        },
        
        decrement() {
            count--;
            log();
        },
        
        getCount() {
            return count;
        }
    };
})();

Counter.increment(); // Count: 1
Counter.increment(); // Count: 2
console.log(Counter.count); // undefined (private)
</code></pre>

        <h3>Revealing Module Pattern</h3>

        <pre><code class="language-javascript">const Calculator = (function() {
    let result = 0;
    
    function add(x) {
        result += x;
        return this;
    }
    
    function subtract(x) {
        result -= x;
        return this;
    }
    
    function getResult() {
        return result;
    }
    
    function reset() {
        result = 0;
    }
    
    // Reveal public methods
    return {
        add,
        subtract,
        getResult,
        reset
    };
})();

Calculator.add(5).add(3).subtract(2);
console.log(Calculator.getResult()); // 6
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Module pattern creates private scope using IIFE</li>
            <li>Uses closures for encapsulation</li>
            <li>Exposes public API through returned object</li>
            <li>Provides privacy before ES6 classes</li>
            <li>Good for namespace management</li>
            <li>Revealing pattern makes code clearer</li>
        </ul>
    </div>


    <!-- Chapter 37: Decorator Pattern -->
    <div id="chapter37" class="page-break">
        <h1>Chapter 37: JavaScript Decorator Pattern</h1>
        <h2>Extend Functionality Dynamically</h2>

        <p>The Decorator pattern allows you to add new behavior to objects or functions dynamically without modifying
            their original code. Instead of using inheritance to extend functionality, decorators wrap the original
            object or function, adding features while maintaining the same interface. This promotes the Open/Closed
            Principle and makes your code more composable.</p>

        <p>In JavaScript, decorators are particularly powerful because functions are first-class citizens. You can
            easily wrap functions to add logging, caching, validation, or any cross-cutting concern. This pattern is
            widely used in frameworks and libraries, and JavaScript even has a proposal for native decorator syntax.</p>

        <h3>Function Decorator</h3>

        <p>Function decorators wrap a function to add behavior before, after, or around the original function call. The
            decorator returns a new function that calls the original while adding extra functionality.</p>

        <pre><code class="language-javascript">function logger(fn) {
    return function(...args) {
        console.log(`Calling ${fn.name} with`, args);
        const result = fn(...args);
        console.log(`Result:`, result);
        return result;
    };
}

function add(a, b) {
    return a + b;
}

const loggedAdd = logger(add);
loggedAdd(2, 3);
// Calling add with [2, 3]
// Result: 5
</code></pre>

        <h3>Memoization Decorator</h3>

        <pre><code class="language-javascript">function memoize(fn) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            console.log('From cache');
            return cache.get(key);
        }
        
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
}

const fibonacci = memoize(function fib(n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
});
</code></pre>

        <h3>API Retry Decorator</h3>

        <pre><code class="language-javascript">function retry(fn, retries = 3) {
    return async function(...args) {
        for (let i = 0; i < retries; i++) {
            try {
                return await fn(...args);
            } catch (error) {
                if (i === retries - 1) throw error;
                await new Promise(r => setTimeout(r, 1000 * (i + 1)));
            }
        }
    };
}

const fetchWithRetry = retry(fetch);
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Decorators add behavior without modifying original code</li>
            <li>Wrap functions/objects to extend functionality</li>
            <li>Composable and reusable</li>
            <li>Alternative to inheritance</li>
            <li>Great for logging, caching, validation</li>
            <li>Follows Open/Closed Principle</li>
        </ul>
    </div>


    <!-- Chapter 38: Facade Pattern -->
    <div id="chapter38" class="page-break">
        <h1>Chapter 38: JavaScript Facade Pattern</h1>
        <h2>Simplify Complex Interfaces</h2>

        <p>The Facade pattern provides a simplified, unified interface to a complex subsystem. It acts as a high-level
            interface that makes the subsystem easier to use by hiding its complexity. This is particularly valuable
            when working with complex libraries, legacy code, or systems with many interdependent classes.</p>

        <p>Facades reduce coupling between client code and the subsystem, making the system easier to understand and
            maintain. They also provide a single entry point for common operations, reducing the learning curve for
            developers who need to use the subsystem. Many popular libraries use facades to provide simple APIs over
            complex implementations.</p>

        <h3>Basic Example</h3>

        <p>A facade wraps multiple subsystem components and provides simple methods that coordinate their interactions.
            The client only needs to know about the facade, not the underlying complexity.</p>

        <pre><code class="language-javascript">// Complex subsystem
class CPU {
    freeze() { console.log('CPU frozen'); }
    jump(position) { console.log(`Jumping to ${position}`); }
    execute() { console.log('Executing'); }
}

class Memory {
    load(position, data) { 
        console.log(`Loading ${data} at ${position}`); 
    }
}

class HardDrive {
    read(sector, size) { 
        console.log(`Reading ${size} from sector ${sector}`);
        return 'boot data';
    }
}

// Facade - simple interface
class ComputerFacade {
    constructor() {
        this.cpu = new CPU();
        this.memory = new Memory();
        this.hardDrive = new HardDrive();
    }
    
    start() {
        this.cpu.freeze();
        const bootData = this.hardDrive.read(0, 1024);
        this.memory.load(0, bootData);
        this.cpu.jump(0);
        this.cpu.execute();
    }
}

// Simple usage
const computer = new ComputerFacade();
computer.start(); // One simple call!
</code></pre>

        <h3>API Facade</h3>

        <pre><code class="language-javascript">class ApiFacade {
    async getUser(id) {
        const response = await fetch(`/api/users/${id}`);
        if (!response.ok) throw new Error('Failed');
        return response.json();
    }
    
    async createUser(data) {
        const response = await fetch('/api/users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        return response.json();
    }
}

const api = new ApiFacade();
const user = await api.getUser(1); // Simple!
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Facade simplifies complex subsystems</li>
            <li>Provides unified, simple interface</li>
            <li>Hides implementation details</li>
            <li>Makes code easier to use and test</li>
            <li>Common in library design</li>
            <li>Reduces coupling to subsystems</li>
        </ul>
    </div>


    <!-- Chapter 39: Strategy Pattern -->
    <div id="chapter39" class="page-break">
        <h1>Chapter 39: JavaScript Strategy Pattern</h1>
        <h2>Interchangeable Algorithms</h2>

        <p>The Strategy pattern defines a family of algorithms, encapsulates each one in a separate class or function,
            and makes them interchangeable. This allows the algorithm to vary independently from the clients that use
            it. Instead of implementing multiple conditional branches, you create separate strategy objects that can be
            swapped at runtime.</p>

        <p>This pattern is excellent for eliminating complex conditional logic and making your code more maintainable.
            When you need to add a new algorithm, you simply create a new strategy without modifying existing code. This
            follows the Open/Closed Principle and makes testing easier since each strategy can be tested independently.
        </p>

        <h3>Basic Example</h3>

        <p>Strategies are typically stored in an object or map, allowing you to select the appropriate algorithm based
            on runtime conditions. The context delegates the work to the selected strategy.</p>

        <pre><code class="language-javascript">// Strategies
const strategies = {
    credit: (amount) => {
        console.log(`Processing ${amount} via credit card`);
        return { success: true, method: 'credit' };
    },
    
    paypal: (amount) => {
        console.log(`Processing ${amount} via PayPal`);
        return { success: true, method: 'paypal' };
    },
    
    crypto: (amount) => {
        console.log(`Processing ${amount} via cryptocurrency`);
        return { success: true, method: 'crypto' };
    }
};

class PaymentProcessor {
    constructor(strategy) {
        this.strategy = strategy;
    }
    
    setStrategy(strategy) {
        this.strategy = strategy;
    }
    
    process(amount) {
        return this.strategy(amount);
    }
}

// Usage
const processor = new PaymentProcessor(strategies.credit);
processor.process(100);

processor.setStrategy(strategies.paypal);
processor.process(50);
</code></pre>

        <h3>Validation Strategy</h3>

        <pre><code class="language-javascript">class Validator {
    constructor(strategy) {
        this.strategy = strategy;
    }
    
    validate(data) {
        return this.strategy.validate(data);
    }
}

const emailStrategy = {
    validate(email) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    }
};

const phoneStrategy = {
    validate(phone) {
        return /^\d{10}$/.test(phone);
    }
};

const validator = new Validator(emailStrategy);
console.log(validator.validate('test@example.com')); // true
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Strategy defines interchangeable algorithms</li>
            <li>Select algorithm at runtime</li>
            <li>Eliminates complex conditional logic</li>
            <li>Follows Open/Closed Principle</li>
            <li>Easy to test and extend</li>
            <li>Common in payment processing and validation</li>
        </ul>
    </div>


    <!-- Chapter 40: Command Pattern -->
    <div id="chapter40" class="page-break">
        <h1>Chapter 40: JavaScript Command Pattern</h1>
        <h2>Encapsulate Requests as Objects</h2>

        <p>The Command pattern turns requests into stand-alone objects that contain all information about the request.
            This transformation enables powerful features like undo/redo, request queuing, logging, and transaction
            management. Commands decouple the object that invokes the operation from the object that knows how to
            perform it.</p>

        <p>This pattern is fundamental to many applications, from text editors with undo/redo to macro recording
            systems. By representing operations as objects, you can store them, pass them around, and execute them at
            different times. This makes it easy to implement features like command history, delayed execution, or batch
            processing.</p>

        <h3>Basic Example</h3>

        <p>Each command object implements an <code>execute()</code> method that performs the operation and an
            <code>undo()</code> method that reverses it. Commands encapsulate both the action and the data needed to
            perform it.
        </p>

        <pre><code class="language-javascript">class Command {
    execute() {}
    undo() {}
}

class AddCommand extends Command {
    constructor(receiver, value) {
        super();
        this.receiver = receiver;
        this.value = value;
    }
    
    execute() {
        this.receiver.add(this.value);
    }
    
    undo() {
        this.receiver.subtract(this.value);
    }
}

class Calculator {
    constructor() {
        this.value = 0;
    }
    
    add(val) {
        this.value += val;
    }
    
    subtract(val) {
        this.value -= val;
    }
}

// Usage
const calc = new Calculator();
const addCmd = new AddCommand(calc, 10);

addCmd.execute(); // calc.value = 10
addCmd.undo();    // calc.value = 0
</code></pre>

        <h3>Undo/Redo Manager</h3>

        <pre><code class="language-javascript">class CommandManager {
    constructor() {
        this.history = [];
        this.current = -1;
    }
    
    execute(command) {
        this.history = this.history.slice(0, this.current + 1);
        command.execute();
        this.history.push(command);
        this.current++;
    }
    
    undo() {
        if (this.current >= 0) {
            this.history[this.current].undo();
            this.current--;
        }
    }
    
    redo() {
        if (this.current < this.history.length - 1) {
            this.current++;
            this.history[this.current].execute();
        }
    }
}

const manager = new CommandManager();
manager.execute(new AddCommand(calc, 5));
manager.undo();
manager.redo();
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Command pattern encapsulates requests as objects</li>
            <li>Enables undo/redo functionality</li>
            <li>Supports command queuing and logging</li>
            <li>Decouples sender from receiver</li>
            <li>Perfect for text editors and transaction systems</li>
            <li>Allows macro recording and playback</li>
        </ul>
    </div>


    <!-- PART IX -->
    <div class="page-break">
        <h1 class="center">Part VIII</h1>
        <h2 class="center">Advanced JavaScript Features</h2>
    </div>

    <!-- Chapter 41: Symbols -->
    <div id="chapter41" class="page-break">
        <h1>Chapter 41: JavaScript Symbols</h1>
        <h2>Unique Identifiers</h2>

        <p>Symbols are a primitive data type introduced in ES6 that creates unique, immutable identifiers. Unlike
            strings or numbers, every symbol is guaranteed to be unique, even if they have the same description. This
            makes symbols perfect for creating property keys that won't conflict with other properties, implementing
            private-like properties, and defining well-known symbols for metaprogramming.</p>

        <p>Symbols solve the problem of property name collisions in JavaScript objects. When multiple libraries or code
            modules add properties to the same object, there's a risk of overwriting each other's properties. Symbols
            provide a way to create truly unique property keys that are hidden from normal property enumeration.</p>

        <h3>Creating Symbols</h3>

        <p>Symbols are created using the <code>Symbol()</code> function (not a constructor). Each call creates a new,
            unique symbol. You can provide an optional description for debugging purposes, but it doesn't affect
            uniqueness.</p>

        <pre><code class="language-javascript">// Create unique symbols
const sym1 = Symbol();
const sym2 = Symbol();
console.log(sym1 === sym2); // false - always unique

// With description
const id = Symbol('id');
const id2 = Symbol('id');
console.log(id === id2); // false - still unique

// Global symbols
const globalSym = Symbol.for('app.id');
const sameSym = Symbol.for('app.id');
console.log(globalSym === sameSym); // true
</code></pre>

        <h3>As Object Properties</h3>

        <pre><code class="language-javascript">const id = Symbol('id');
const user = {
    name: 'John',
    [id]: 123
};

console.log(user[id]); // 123
console.log(user.id); // undefined

// Symbols are hidden from iteration
for (let key in user) {
    console.log(key); // Only 'name', not symbol
}

Object.keys(user); // ['name']
Object.getOwnPropertySymbols(user); // [Symbol(id)]
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Symbols are always unique</li>
            <li>Use as private-like object properties</li>
            <li>Hidden from normal iteration</li>
            <li>Symbol.for() creates global symbols</li>
            <li>Good for avoiding property name collisions</li>
        </ul>
    </div>


    <!-- Chapter 42: BigInt -->
    <div id="chapter42" class="page-break">
        <h1>Chapter 42: JavaScript BigInt</h1>
        <h2>Arbitrary Precision Integers</h2>

        <p>BigInt is a primitive type that allows you to work with integers of arbitrary size, beyond JavaScript's safe
            integer limit of 2^53 - 1. Regular JavaScript numbers use 64-bit floating-point representation, which limits
            the precision of large integers. BigInt solves this by providing true integer arithmetic for values of any
            size.</p>

        <p>BigInt is essential for applications that need precise integer calculations with very large numbers, such as
            cryptography, high-precision timestamps, or financial calculations. However, BigInts cannot be mixed with
            regular numbers in arithmetic operations, and they don't work with Math object methods.</p>

        <h3>Creating BigInts</h3>

        <p>BigInts are created by appending 'n' to an integer literal or by calling the <code>BigInt()</code> function.
            The function can accept strings, which is useful for creating BigInts from values that exceed JavaScript's
            number precision.</p>

        <pre><code class="language-javascript">// Using 'n' suffix
const big1 = 123456789012345678901234567890n;

// Using BigInt()
const big2 = BigInt('123456789012345678901234567890');
const big3 = BigInt(123);

// Cannot mix with regular numbers
const result = 10n + 20n; // 30n
// const mixed = 10n + 20; // TypeError!
</code></pre>

        <h3>Operations</h3>

        <pre><code class="language-javascript">const a = 100n;
const b = 50n;

console.log(a + b); // 150n
console.log(a - b); // 50n
console.log(a * b); // 5000n
console.log(a / b); // 2n (integer division)
console.log(a % b); // 0n

// Comparisons work
console.log(10n > 5n); // true
console.log(10n === 10); // false (different types)
console.log(10n == 10); // true (loose equality)
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>BigInt handles arbitrarily large integers</li>
            <li>Use 'n' suffix or BigInt() constructor</li>
            <li>Cannot mix with regular Numbers in operations</li>
            <li>Division always returns integer result</li>
            <li>Perfect for cryptography and large calculations</li>
        </ul>
    </div>


    <!-- Chapter 45: Typed Arrays -->
    <div id="chapter45" class="page-break">
        <h1>Chapter 45: JavaScript Typed Arrays</h1>
        <h2>Binary Data Handling</h2>

        <p>Typed Arrays provide a mechanism for accessing raw binary data efficiently. Unlike regular JavaScript arrays
            that can hold any type of value, typed arrays are views over ArrayBuffer objects that store data in a
            specific numeric format. This makes them much faster and more memory-efficient for numerical computations
            and binary data manipulation.</p>

        <p>Typed Arrays are essential for working with WebGL, Canvas, Web Audio API, File API, and other
            performance-critical operations that deal with binary data. They provide C-like performance for numerical
            operations while maintaining JavaScript's ease of use.</p>

        <h3>Creating Typed Arrays</h3>

        <p>Typed Arrays are created from an ArrayBuffer, which represents a fixed-length raw binary data buffer.
            Different typed array views (Int8Array, Uint8Array, Float32Array, etc.) interpret the buffer's bytes in
            different ways.</p>

        <pre><code class="language-javascript">// Create buffer
const buffer = new ArrayBuffer(16); // 16 bytes

// Create views
const int8View = new Int8Array(buffer);
const int16View = new Int16Array(buffer);
const int32View = new Int32Array(buffer);

// Direct creation
const arr = new Uint8Array([1, 2, 3, 4]);
console.log(arr.length); // 4
console.log(arr[0]); // 1
</code></pre>

        <h3>Common Types</h3>

        <pre><code class="language-javascript">// Unsigned integers
const uint8 = new Uint8Array(4); // 0-255
const uint16 = new Uint16Array(4); // 0-65535
const uint32 = new Uint32Array(4); // 0-4294967295

// Signed integers
const int8 = new Int8Array(4); // -128 to 127
const int16 = new Int16Array(4); // -32768 to 32767

// Floating point
const float32 = new Float32Array(4);
const float64 = new Float64Array(4);
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Typed Arrays handle binary data efficiently</li>
            <li>Fixed size and type</li>
            <li>Better performance than regular arrays for numeric data</li>
            <li>Used in WebGL, Canvas, File API</li>
            <li>ArrayBuffer is the underlying memory</li>
        </ul>
    </div>


    <!-- Chapter 44: Regular Expressions -->
    <div id="chapter44" class="page-break">
        <h1>Chapter 44: JavaScript Regular Expressions</h1>
        <h2>Pattern Matching</h2>

        <p>Regular expressions (regex) are patterns used to match character combinations in strings. They provide a
            powerful, concise way to search, validate, and manipulate text. While regex syntax can seem cryptic at
            first, mastering regular expressions is essential for tasks like form validation, data parsing, and text
            processing.</p>

        <p>JavaScript's regex implementation is based on Perl's regular expressions, with some differences. Regular
            expressions in JavaScript are objects that can be created using literal notation or the RegExp constructor.
            They're used with string methods like <code>match()</code>, <code>replace()</code>, <code>search()</code>,
            and <code>split()</code>.</p>

        <h3>Basic Patterns</h3>

        <p>Regular expressions can be created using literal notation (between forward slashes) or the RegExp
            constructor. Flags like 'i' (case-insensitive), 'g' (global), and 'm' (multiline) modify how the pattern
            matches.</p>

        <pre><code class="language-javascript">// Literal notation
const regex1 = /hello/;
const regex2 = /hello/i; // case-insensitive

// Constructor
const regex3 = new RegExp('hello', 'i');

// Test for match
console.log(/hello/.test('hello world')); // true
console.log(/hello/.test('Hi there')); // false

// Find matches
const str = 'hello world';
const match = str.match(/hello/);
console.log(match[0]); // 'hello'
</code></pre>

        <h3>Common Patterns</h3>

        <pre><code class="language-javascript">// Email validation
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
console.log(emailRegex.test('user@example.com')); // true

// Phone number
const phoneRegex = /^\d{3}-\d{3}-\d{4}$/;
console.log(phoneRegex.test('555-123-4567')); // true

// URL
const urlRegex = /^https?:\/\/.+/;
console.log(urlRegex.test('https://example.com')); // true

// Replace
const text = 'hello world';
const newText = text.replace(/hello/, 'hi');
console.log(newText); // 'hi world'
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Use /pattern/flags for regex literals</li>
            <li>test() checks for matches</li>
            <li>match() returns matched strings</li>
            <li>replace() substitutes patterns</li>
            <li>Flags: i (case-insensitive), g (global), m (multiline)</li>
        </ul>
    </div>


    <!-- Chapter 47: Proxies -->
    <div id="chapter47" class="page-break">
        <h1>Chapter 47: JavaScript Proxies</h1>
        <h2>Intercept Object Operations</h2>

        <p>Proxies are a powerful metaprogramming feature that allows you to intercept and redefine fundamental
            operations on objects. A Proxy wraps another object (the target) and intercepts operations like property
            access, assignment, enumeration, and function invocation. This enables you to add custom behavior to objects
            without modifying their original code.</p>

        <p>Proxies are used in reactive frameworks (like Vue 3), validation systems, logging, data binding, and creating
            virtual properties. They provide a way to implement aspect-oriented programming in JavaScript, separating
            cross-cutting concerns from business logic.</p>

        <h3>Basic Proxy</h3>

        <p>A Proxy is created with a target object and a handler object containing trap functions. Traps intercept
            operations and can modify their behavior. The most common traps are <code>get</code> and <code>set</code>.
        </p>

        <pre><code class="language-javascript">const target = { name: 'John', age: 30 };

const handler = {
    get(target, prop) {
        console.log(`Getting ${prop}`);
        return target[prop];
    },
    
    set(target, prop, value) {
        console.log(`Setting ${prop} to ${value}`);
        target[prop] = value;
        return true;
    }
};

const proxy = new Proxy(target, handler);
console.log(proxy.name); // Logs: Getting name, then: John
proxy.age = 31; // Logs: Setting age to 31
</code></pre>

        <h3>Validation</h3>

        <pre><code class="language-javascript">const validator = {
    set(target, prop, value) {
        if (prop === 'age') {
            if (typeof value !== 'number') {
                throw new TypeError('Age must be a number');
            }
            if (value < 0) {
                throw new RangeError('Age must be positive');
            }
        }
        target[prop] = value;
        return true;
    }
};

const person = new Proxy({}, validator);
person.age = 30; // OK
// person.age = 'thirty'; // TypeError
// person.age = -5; // RangeError
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Proxies intercept object operations</li>
            <li>Handler traps: get, set, has, deleteProperty, etc.</li>
            <li>Perfect for validation and logging</li>
            <li>Can create virtual properties</li>
            <li>Used in reactive frameworks (Vue 3)</li>
        </ul>
    </div>


    <!-- Chapter 46: Iterators -->
    <div id="chapter46" class="page-break">
        <h1>Chapter 46: JavaScript Iterators</h1>
        <h2>Custom Iteration</h2>

        <p>Iterators are objects that define a sequence and potentially a return value upon completion. They implement
            the iterator protocol by having a <code>next()</code> method that returns objects with <code>value</code>
            and <code>done</code> properties. Iterators enable custom iteration behavior for objects, making them work
            with <code>for...of</code> loops and other iteration constructs.</p>

        <p>Understanding iterators is fundamental to working with generators, async iteration, and creating custom data
            structures. Many built-in JavaScript objects (arrays, strings, maps, sets) are iterable by default, but you
            can make any object iterable by implementing the iterator protocol.</p>

        <h3>Creating Iterators</h3>

        <p>To make an object iterable, you implement the <code>Symbol.iterator</code> method that returns an iterator
            object. The iterator's <code>next()</code> method is called repeatedly to get successive values.</p>

        <pre><code class="language-javascript">const range = {
    from: 1,
    to: 5,
    
    [Symbol.iterator]() {
        return {
            current: this.from,
            last: this.to,
            
            next() {
                if (this.current <= this.last) {
                    return { value: this.current++, done: false };
                }
                return { done: true };
            }
        };
    }
};

for (let num of range) {
    console.log(num); // 1, 2, 3, 4, 5
}
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Iterators implement Symbol.iterator</li>
            <li>next() returns {value, done}</li>
            <li>Enables for...of loops</li>
            <li>Generators simplify iterator creation</li>
        </ul>
    </div>


    <!-- Chapter 47: Encapsulation -->
    <div id="chapter47" class="page-break">
        <h1>Chapter 47: JavaScript Encapsulation</h1>
        <h2>Data Hiding</h2>

        <p>Encapsulation is a fundamental principle of object-oriented programming that bundles data and methods
            together while hiding internal implementation details. In JavaScript, encapsulation prevents external code
            from directly accessing or modifying an object's internal state, reducing coupling and making code more
            maintainable and less prone to bugs.</p>

        <p>Modern JavaScript provides multiple ways to achieve encapsulation: private fields (using #), closures,
            WeakMaps, and symbols. Each approach has trade-offs in terms of syntax, performance, and compatibility.
            Private fields are now the standard approach, offering true privacy with clean syntax.</p>

        <h3>Private Fields</h3>

        <p>Private fields, denoted by a # prefix, are truly private and inaccessible from outside the class. They're
            part of the class syntax and provide compile-time privacy guarantees.</p>

        <pre><code class="language-javascript">class BankAccount {
    #balance = 0;
    
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
        }
    }
    
    getBalance() {
        return this.#balance;
    }
}

const account = new BankAccount();
account.deposit(100);
console.log(account.getBalance()); // 100
// console.log(account.#balance); // SyntaxError
</code></pre>

        <h3>Closures</h3>

        <pre><code class="language-javascript">function createCounter() {
    let count = 0; // Private
    
    return {
        increment() { count++; },
        decrement() { count--; },
        getCount() { return count; }
    };
}

const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // 1
// console.log(counter.count); // undefined
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Private fields use # prefix</li>
            <li>Closures create private variables</li>
            <li>Encapsulation improves maintainability</li>
            <li>Exposes minimal public interface</li>
        </ul>
    </div>


    <!-- PART X -->
    <div class="page-break">
        <h1 class="center">Part IX</h1>
        <h2 class="center">Functional JavaScript</h2>
    </div>

    <!-- Chapter 48 -->
    <div id="chapter48" class="page-break">
        <h1>Chapter 48: JavaScript Immutability and Pure Functions</h1>
        <h2>Write Predictable, Bug-Free Code</h2>

        <p>Immutability means data cannot be changed after creation. Pure functions always return the same output for
            the
            same input and have no side effects.</p>

        <h3>Immutable Array Operations</h3>

        <pre><code class="language-javascript">const arr = [1, 2, 3];

// Mutable (BAD)
arr.push(4);

// Immutable (GOOD)
const newArr = [...arr, 4];
const withoutLast = arr.slice(0, -1);
const updated = arr.map((val, i) => i === 2 ? 99 : val);
</code></pre>

        <h3>Immutable Object Operations</h3>

        <pre><code class="language-javascript">const user = { name: 'John', age: 30 };

// Mutable (BAD)
user.age = 31;

// Immutable (GOOD)
const updatedUser = { ...user, age: 31 };

// Nested updates
const updated = {
    ...user,
    address: {
        ...user.address,
        city: 'Boston'
    }
};
</code></pre>

        <h3>Object.freeze()</h3>

        <pre><code class="language-javascript">const user = Object.freeze({ name: 'John', age: 30 });
user.age = 31; // Fails silently
console.log(user); // { name: 'John', age: 30 }
</code></pre>

        <h3>Pure Functions</h3>

        <pre><code class="language-javascript">// Impure - modifies external state
let total = 0;
function addToTotal(value) {
    total += value;
    return total;
}

// Pure - no side effects
function add(a, b) {
    return a + b;
}
</code></pre>

        <h3>Real-World Example: Redux Reducer</h3>

        <pre><code class="language-javascript">function todosReducer(state = initialState, action) {
    switch (action.type) {
        case 'ADD_TODO':
            return {
                ...state,
                todos: [...state.todos, { id: Date.now(), text: action.text }]
            };
        case 'TOGGLE_TODO':
            return {
                ...state,
                todos: state.todos.map(todo =>
                    todo.id === action.id
                        ? { ...todo, completed: !todo.completed }
                        : todo
                )
            };
        default:
            return state;
    }
}
</code></pre>

        <h3>Key Takeaways</h3>

        <ul>
            <li>Immutability means data cannot be changed after creation</li>
            <li>Pure functions have no side effects</li>
            <li>Use spread operator (...) for immutable updates</li>
            <li>Array methods like map, filter, reduce are immutable</li>
            <li>Avoid push, pop, splice, and direct property assignment</li>
            <li>Object.freeze() provides shallow immutability</li>
            <li>Immutability makes code more predictable and easier to debug</li>
        </ul>
    </div>


    <!-- Chapter 49 -->
    <div id="chapter49" class="page-break">
        <h1>Chapter 49: JavaScript Function Composition and Pipelines</h1>
        <h2>Build Complex Logic from Simple Functions</h2>

        <p>Function composition is the process of combining two or more functions to create a new function. It's one of
            the most powerful patterns in functional programming.</p>

        <h3>The compose Function</h3>

        <p>Compose applies functions from right to left:</p>

        <pre><code class="language-javascript">const compose = (...fns) => x => 
    fns.reduceRight((acc, fn) => fn(acc), x);

const double = x => x * 2;
const addTen = x => x + 10;

const doubleThenAddTen = compose(addTen, double);
console.log(doubleThenAddTen(5)); // 20
</code></pre>

        <h3>The pipe Function</h3>

        <p>Pipe applies functions from left to right:</p>

        <pre><code class="language-javascript">const pipe = (...fns) => x => 
    fns.reduce((acc, fn) => fn(acc), x);

const doubleThenAddTen = pipe(double, addTen);
console.log(doubleThenAddTen(5)); // 20
</code></pre>

        <h3>Real-World Example: Data Transformation</h3>

        <pre><code class="language-javascript">const trim = str => str.trim();
const toLowerCase = str => str.toLowerCase();
const removeSpaces = str => str.replace(/\s+/g, '-');
const addPrefix = prefix => str => `${prefix}${str}`;

const createSlug = pipe(
    trim,
    toLowerCase,
    removeSpaces,
    addPrefix('blog-')
);

console.log(createSlug('  Hello World  ')); // "blog-hello-world"
</code></pre>

        <h3>Point-Free Style</h3>

        <p>Point-free style means writing functions without mentioning their arguments:</p>

        <pre><code class="language-javascript">// Impure - modifies external state
let total = 0;
function addToTotal(value) {
    total += value;
    return total;
}

// Pure - no side effects
function add(a, b) {
    return a + b;
}
</code></pre>

        <h3>Async Function Composition</h3>

        <pre><code class="language-javascript">const asyncPipe = (...fns) => x =>
    fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x));

const greetUser = asyncPipe(
    fetchUser,
    extractName,
    toUpperCase,
    addGreeting
);

greetUser(1).then(console.log); // "Hello, JOHN!"
</code></pre>

        <h3>Key Takeaways</h3>

        <ul>
            <li>Composition combines functions to create new functions</li>
            <li><code>compose</code> applies functions right-to-left</li>
            <li><code>pipe</code> applies functions left-to-right</li>
            <li>Curry functions to make them composable</li>
            <li>Point-free style eliminates argument noise</li>
            <li>Use <code>asyncPipe</code> for async function composition</li>
        </ul>
    </div>


    <!-- Chapter 50 -->
    <div id="chapter48" class="page-break">
        <h1>Chapter 50: JavaScript Functors and Applicatives</h1>
        <h2>Master Functional Patterns</h2>

        <p>Functors and Applicatives are fundamental patterns in functional programming that let you work with values in
            containers without unwrapping them.</p>

        <h3>What is a Functor?</h3>

        <p>A functor is a container that implements a <code>map</code> method. The <code>map</code> method applies a
            function to the value(s) inside the container and returns a new container with the transformed value(s).</p>

        <p><strong>Implementation:</strong></p>

        <pre><code class="language-javascript">class Box {
    constructor(value) {
        this.value = value;
    }

    map(fn) {
        return new Box(fn(this.value));
    }
}

const box = new Box(5);
const result = box.map(x => x * 2).map(x => x + 10);
console.log(result); // Box(20)
</code></pre>

        <p>Each <code>map</code> transforms the value inside the box and returns a new box. You never directly access
            the
            value.</p>

        <h3>The Functor Laws</h3>

        <ol>
            <li><strong>Identity:</strong> <code>box.map(x => x)</code> should equal <code>box</code></li>
            <li><strong>Composition:</strong> <code>box.map(f).map(g)</code> should equal
                <code>box.map(x => g(f(x)))</code>
            </li>
        </ol>

        <h3>What is an Applicative Functor?</h3>

        <p>An applicative functor can apply a wrapped function to a wrapped value. It has <code>of</code> and
            <code>ap</code> methods.
        </p>

        <p><strong>Implementation:</strong></p>

        <pre><code class="language-javascript">class Box {
    static of(value) {
        return new Box(value);
    }

    map(fn) {
        return Box.of(fn(this.value));
    }

    ap(boxWithFunction) {
        return boxWithFunction.map(fn => fn(this.value));
    }
}

const add = a => b => a + b;
const result = Box.of(5).map(add).ap(Box.of(10));
console.log(result); // Box(15)
</code></pre>

        <h3>Real-World Example: Form Validation</h3>

        <pre><code class="language-javascript">class Validation {
    constructor(value, isValid = true) {
        this.value = value;
        this.isValid = isValid;
    }

    static success(value) {
        return new Validation(value, true);
    }

    static failure(error) {
        return new Validation(error, false);
    }

    map(fn) {
        return this.isValid ? Validation.success(fn(this.value)) : this;
    }

    ap(validationWithFn) {
        if (!this.isValid) return this;
        if (!validationWithFn.isValid) return validationWithFn;
        return this.map(validationWithFn.value);
    }
}

const createUser = name => email => age => ({ name, email, age });

const user = validateName('John')
    .map(createUser)
    .ap(validateEmail('john@example.com'))
    .ap(validateAge(25));
</code></pre>

        <h3>Key Takeaways</h3>

        <ul>
            <li>Functors implement <code>map</code> to transform wrapped values</li>
            <li>Applicatives add <code>ap</code> to apply wrapped functions to wrapped values</li>
            <li>Use applicatives to combine multiple wrapped values</li>
            <li>Curry functions to use them with applicatives</li>
            <li>Every monad is an applicative, every applicative is a functor</li>
        </ul>
    </div>


    <!-- Chapter 51 -->
    <div id="chapter51" class="page-break">
        <h1>Chapter 51: JavaScript Monads</h1>
        <h2>Master Functional Programming Patterns</h2>

        <p>Monads sound intimidating, but they're just a design pattern for handling values in a predictable way. They
            help you write safer code by making error handling, null checks, and side effects explicit and composable.
        </p>

        <h3>What is a Monad?</h3>

        <p>A monad is a design pattern that wraps a value and provides a way to chain operations on that value. Think of
            it as a box that:</p>
        <ul>
            <li>Contains a value</li>
            <li>Provides a way to transform the value (<code>map</code>)</li>
            <li>Provides a way to chain operations that return new monads (<code>flatMap</code> or <code>chain</code>)
            </li>
        </ul>

        <p>Monads help you handle edge cases (null, errors, side effects) in a consistent, composable way.</p>

        <h3>The Maybe Monad: Handling Null Safety</h3>

        <p>The Maybe monad handles values that might be null or undefined.</p>

        <p><strong>Implementation:</strong></p>

        <pre><code class="language-javascript">class Maybe {
    constructor(value) {
        this.value = value;
    }

    static of(value) {
        return new Maybe(value);
    }

    isNothing() {
        return this.value === null || this.value === undefined;
    }

    map(fn) {
        return this.isNothing() ? this : Maybe.of(fn(this.value));
    }

    flatMap(fn) {
        return this.isNothing() ? this : fn(this.value);
    }

    getOrElse(defaultValue) {
        return this.isNothing() ? defaultValue : this.value;
    }
}
</code></pre>

        <p><strong>Usage Example:</strong></p>

        <pre><code class="language-javascript">// Without Maybe - lots of null checks
function getUserDiscount(userId) {
    const user = findUser(userId);
    if (!user) return 0;
    const membership = user.membership;
    if (!membership) return 0;
    const discount = membership.discount;
    if (!discount) return 0;
    return discount;
}

// With Maybe - clean and safe
function getUserDiscount(userId) {
    return Maybe.of(findUser(userId))
        .map(user => user.membership)
        .map(membership => membership.discount)
        .getOrElse(0);
}
</code></pre>

        <p>If any step returns null/undefined, <code>map</code> stops executing and returns <code>Nothing</code>. No
            null
            checks needed!</p>

        <h3>The Either Monad: Handling Errors</h3>

        <p>The Either monad represents a value that can be one of two types: <code>Left</code> (error) or
            <code>Right</code> (success).
        </p>

        <p><strong>Implementation:</strong></p>

        <pre><code class="language-javascript">class Either {
    constructor(value, isLeft = false) {
        this.value = value;
        this.isLeft = isLeft;
    }

    static left(value) {
        return new Either(value, true);
    }

    static right(value) {
        return new Either(value, false);
    }

    map(fn) {
        return this.isLeft ? this : Either.right(fn(this.value));
    }

    flatMap(fn) {
        return this.isLeft ? this : fn(this.value);
    }

    fold(leftFn, rightFn) {
        return this.isLeft ? leftFn(this.value) : rightFn(this.value);
    }
}
</code></pre>

        <p><strong>Usage Example:</strong></p>

        <pre><code class="language-javascript">function validateEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email)
        ? Either.right(email)
        : Either.left('Invalid email format');
}

function validateAge(age) {
    return age >= 18
        ? Either.right(age)
        : Either.left('Must be 18 or older');
}

function createUser(email, age) {
    return validateEmail(email)
        .flatMap(() => validateAge(age))
        .map(() => ({ email, age, createdAt: new Date() }))
        .fold(
            error => ({ success: false, error }),
            user => ({ success: true, user })
        );
}
</code></pre>

        <p>If any step returns <code>Left</code> (error), the chain stops and the error propagates. Only
            <code>Right</code> values continue.
        </p>

        <h3>The IO Monad: Handling Side Effects</h3>

        <p>The IO monad wraps side effects to keep your functions pure. The side effect doesn't execute until you
            explicitly run it.</p>

        <p><strong>Implementation:</strong></p>

        <pre><code class="language-javascript">class IO {
    constructor(effect) {
        this.effect = effect;
    }

    static of(value) {
        return new IO(() => value);
    }

    map(fn) {
        return new IO(() => fn(this.effect()));
    }

    flatMap(fn) {
        return new IO(() => fn(this.effect()).effect());
    }

    run() {
        return this.effect();
    }
}
</code></pre>

        <p><strong>Usage Example:</strong></p>

        <pre><code class="language-javascript">function fetchUserIO(userId) {
    return new IO(() => fetch(`/api/users/${userId}`).then(r => r.json()));
}

function displayDataIO(data) {
    return new IO(() => {
        document.getElementById('output').textContent = JSON.stringify(data);
    });
}

// Build the program (no side effects yet)
const program = fetchUserIO(1).flatMap(displayDataIO);

// Execute when ready
document.getElementById('loadBtn').addEventListener('click', () => {
    program.run();
});
</code></pre>

        <p>The IO monad lets you compose side effects without executing them, making your code testable.</p>

        <h3>Common Pitfalls</h3>

        <p><strong>Pitfall 1: Forgetting to run IO</strong></p>

        <pre><code class="language-javascript">// Wrong - IO never executes
const io = new IO(() => console.log('Hello'));

// Right - call run()
io.run();
</code></pre>

        <p><strong>Pitfall 2: Using map instead of flatMap</strong></p>

        <pre><code class="language-javascript">// Wrong - creates nested monads
Maybe.of(5).map(x => Maybe.of(x * 2)); // Maybe(Maybe(10))

// Right - use flatMap to flatten
Maybe.of(5).flatMap(x => Maybe.of(x * 2)); // Maybe(10)
</code></pre>

        <p><strong>Pitfall 3: Overusing monads</strong></p>

        <p>Not everything needs to be a monad. Use them when they solve a real problem (null safety, error handling,
            side
            effects).</p>

        <h3>Key Takeaways</h3>

        <ul>
            <li>Monads are containers that provide <code>map</code> and <code>flatMap</code> for chaining operations
            </li>
            <li>Maybe monad handles null/undefined values safely</li>
            <li>Either monad handles errors functionally without try-catch</li>
            <li>IO monad defers side effects, keeping functions pure</li>
            <li>Use <code>map</code> for transformations, <code>flatMap</code> for operations that return monads</li>
            <li>Monads make code more composable, testable, and predictable</li>
        </ul>
    </div>


    <!-- PART XI -->
    <div class="page-break">
        <h1 class="center">Part X</h1>
        <h2 class="center">Testing</h2>
    </div>

    <!-- Chapter 52: Unit Testing -->
    <div id="chapter52" class="page-break">
        <h1>Chapter 52: JavaScript Unit Testing</h1>
        <h2>Test Individual Functions</h2>

        <p>Unit testing is the practice of testing individual units of code (functions, methods, classes) in isolation
            to ensure they work correctly. Unit tests are the foundation of a robust testing strategy, providing fast
            feedback, catching bugs early, and serving as living documentation of how code should behave. They're
            typically automated and run frequently during development.</p>

        <p>Good unit tests are fast, isolated, repeatable, and focused on a single behavior. They follow the
            Arrange-Act-Assert pattern: set up the test data, execute the code under test, and verify the results.
            Popular JavaScript testing frameworks like Jest, Vitest, and Mocha provide the tools to write and run unit
            tests efficiently.</p>

        <h3>Basic Test Structure</h3>

        <p>Tests are organized into test suites using <code>describe()</code> blocks and individual test cases using
            <code>test()</code> or <code>it()</code>. Assertions verify that the code behaves as expected.
        </p>

        <pre><code class="language-javascript">// Function to test
function add(a, b) {
    return a + b;
}

// Test with Jest
test('adds two numbers', () => {
    expect(add(2, 3)).toBe(5);
    expect(add(-1, 1)).toBe(0);
    expect(add(0, 0)).toBe(0);
});

// Test suite
describe('Calculator', () => {
    test('addition', () => {
        expect(add(1, 2)).toBe(3);
    });
    
    test('handles negative numbers', () => {
        expect(add(-1, -2)).toBe(-3);
    });
});
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Unit tests verify individual functions</li>
            <li>Use describe() to group related tests</li>
            <li>test() or it() defines test cases</li>
            <li>expect() makes assertions</li>
            <li>Keep tests isolated and independent</li>
        </ul>
    </div>


    <!-- Chapter 53: Integration Testing -->
    <div id="chapter53" class="page-break">
        <h1>Chapter 53: JavaScript Integration Testing</h1>
        <h2>Test Component Interactions</h2>

        <p>Integration testing verifies that different parts of your application work together correctly. While unit
            tests focus on individual components in isolation, integration tests ensure that components interact
            properly when combined. These tests catch issues that unit tests miss, such as incorrect API contracts,
            database integration problems, or misconfigured dependencies.</p>

        <p>Integration tests are slower than unit tests because they involve multiple components and often external
            systems like databases or APIs. However, they provide higher confidence that your application works as a
            whole. The key is finding the right balance between unit and integration tests.</p>

        <h3>Testing API Integration</h3>

        <p>Integration tests often involve testing how your code interacts with external APIs or services. You can test
            against real APIs, mock servers, or use tools like MSW (Mock Service Worker) to intercept network requests.
        </p>

        <pre><code class="language-javascript">test('fetches user data', async () => {
    const user = await fetchUser(1);
    
    expect(user).toHaveProperty('id', 1);
    expect(user).toHaveProperty('name');
    expect(user).toHaveProperty('email');
});

test('creates and retrieves user', async () => {
    const newUser = await createUser({ name: 'John' });
    const retrieved = await getUser(newUser.id);
    
    expect(retrieved.name).toBe('John');
});
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Integration tests verify component interactions</li>
            <li>Test real API calls or use mocks</li>
            <li>Slower than unit tests</li>
            <li>Catch integration issues early</li>
        </ul>
    </div>


    <!-- Chapter 54: Mocking -->
    <div id="chapter54" class="page-break">
        <h1>Chapter 54: JavaScript Mocking</h1>
        <h2>Isolate Tests</h2>

        <p>Mocking is the practice of replacing real dependencies with controlled substitutes during testing. Mocks
            allow you to isolate the code under test, control its environment, and verify interactions with
            dependencies. This makes tests faster, more reliable, and independent of external systems like databases,
            APIs, or file systems.</p>

        <p>Different types of test doubles serve different purposes: mocks verify behavior, stubs provide canned
            responses, spies record information about calls, and fakes are working implementations. Understanding when
            to use each type is crucial for writing effective tests.</p>

        <h3>Mock Functions</h3>

        <p>Mock functions (also called spies) replace real functions and record information about how they were called.
            Testing frameworks like Jest provide built-in mock functions with methods to verify calls and control return
            values.</p>

        <pre><code class="language-javascript">// Create mock
const mockFn = jest.fn();
mockFn.mockReturnValue(42);

console.log(mockFn()); // 42
expect(mockFn).toHaveBeenCalled();

// Mock implementation
const mockCallback = jest.fn(x => x * 2);
const result = [1, 2, 3].map(mockCallback);

expect(result).toEqual([2, 4, 6]);
expect(mockCallback).toHaveBeenCalledTimes(3);
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Mocks replace real dependencies</li>
            <li>Control return values and behavior</li>
            <li>Verify function calls</li>
            <li>Isolate code under test</li>
        </ul>
    </div>


    <!-- Chapter 55: TDD -->
    <div id="chapter55" class="page-break">
        <h1>Chapter 55: Test-Driven Development</h1>
        <h2>Write Tests First</h2>

        <p>Test-Driven Development (TDD) is a software development methodology where you write tests before writing the
            implementation code. The TDD cycle follows three steps: Red (write a failing test), Green (write minimal
            code to pass the test), and Refactor (improve the code while keeping tests passing). This approach leads to
            better-designed, more testable code with comprehensive test coverage.</p>

        <p>TDD provides immediate feedback, ensures all code is testable, and creates a safety net for refactoring. The
            tests serve as executable specifications and documentation. While TDD requires discipline and practice, it
            often results in fewer bugs and more maintainable code.</p>

        <h3>TDD Cycle</h3>

        <p>The Red-Green-Refactor cycle is the heart of TDD. You start by writing a test that fails, then write just
            enough code to make it pass, and finally refactor to improve the design while keeping tests green.</p>

        <pre><code class="language-javascript">// 1. Write failing test
test('validates email', () => {
    expect(isValidEmail('test@example.com')).toBe(true);
    expect(isValidEmail('invalid')).toBe(false);
});

// 2. Write minimal code to pass
function isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

// 3. Refactor if needed
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>Red-Green-Refactor cycle</li>
            <li>Write test first, then implementation</li>
            <li>Ensures code is testable</li>
            <li>Provides living documentation</li>
        </ul>
    </div>


    <!-- Chapter 56: E2E Testing -->
    <div id="chapter56" class="page-break">
        <h1>Chapter 56: End-to-End Testing</h1>
        <h2>Test Complete User Flows</h2>

        <p>End-to-End (E2E) testing simulates real user scenarios by testing your application from start to finish in a
            real browser environment. Unlike unit or integration tests, E2E tests verify that all layers of your
            application (frontend, backend, database, external services) work together correctly. They provide the
            highest confidence that your application works as users expect.</p>

        <p>E2E tests are the slowest and most expensive to write and maintain, but they catch issues that other tests
            miss, such as UI bugs, integration problems, and workflow issues. Modern tools like Playwright and Cypress
            make E2E testing more reliable and developer-friendly with features like automatic waiting, time-travel
            debugging, and parallel execution.</p>

        <h3>Playwright Example</h3>

        <p>Playwright provides a high-level API for automating browsers. Tests interact with the page like a real user
            would - clicking buttons, filling forms, and verifying content.</p>

        <pre><code class="language-javascript">test('user can login', async ({ page }) => {
    await page.goto('https://example.com/login');
    
    await page.fill('#email', 'user@example.com');
    await page.fill('#password', 'password123');
    await page.click('button[type="submit"]');
    
    await expect(page).toHaveURL('https://example.com/dashboard');
    await expect(page.locator('h1')).toContainText('Welcome');
});

test('shopping cart flow', async ({ page }) => {
    await page.goto('https://example.com/products');
    await page.click('.product:first-child .add-to-cart');
    await page.click('.cart-icon');
    
    await expect(page.locator('.cart-items')).toHaveCount(1);
});
</code></pre>

        <h3>Key Takeaways</h3>
        <ul>
            <li>E2E tests simulate real user interactions</li>
            <li>Test complete workflows</li>
            <li>Run in real browsers</li>
            <li>Slowest but most comprehensive tests</li>
            <li>Catch integration and UI issues</li>
            <li>Use Playwright, Cypress, or Selenium</li>
        </ul>
    </div>


    <!-- Conclusion -->
    <div id="conclusion" class="page-break">
        <h1>Conclusion</h1>

        <p>Congratulations! You've completed this journey through essential JavaScript concepts. From understanding data
            types and hoisting to mastering closures, currying, the <code>this</code> keyword, Promises, async/await,
            generators,
            monads, functors, composition, and immutability - plus modern syntax, design patterns, and browser APIs -
            you now have a comprehensive foundation in JavaScript development.</p>

        <h3>What's Next?</h3>

        <h4>Practice, Practice, Practice</h4>
        <p>Reading about these concepts is just the first step. The real learning happens when you apply them in your
            projects. Try to:</p>
        <ul>
            <li>Refactor existing code using closures for better encapsulation</li>
            <li>Use currying to create reusable function factories</li>
            <li>Replace callbacks with Promises and async/await</li>
            <li>Experiment with generators for data processing</li>
        </ul>

        <h4>Keep Learning</h4>
        <p>JavaScript is constantly evolving. Stay up to date with:</p>
        <ul>
            <li>New ECMAScript features</li>
            <li>Modern frameworks and libraries</li>
            <li>Best practices and design patterns</li>
            <li>Performance optimization techniques</li>
        </ul>

        <h4>Share Your Knowledge</h4>
        <p>Teaching others is one of the best ways to solidify your understanding. Write blog posts, answer questions on
            Stack Overflow, or mentor junior developers.</p>

        <h3>Final Thoughts</h3>
        <p>JavaScript's quirks and features can be confusing, but they're also what makes it powerful and flexible.
            Understanding these core concepts will make you a better developer, help you write cleaner code, and prepare
            you for technical interviews.</p>

        <p>Keep this book handy as a reference. When you encounter unexpected behavior or need a refresher on a concept,
            come back to the relevant chapter.</p>

        <p>Happy coding!</p>
    </div>

    <!-- About the Author -->
    <div id="author" class="page-break">
        <h1>About the Author</h1>

        <p><strong>Bohdan Tsap</strong> is a Full Stack Software Engineer specializing in React and Java/Spring, with
            expertise in distributed and cloud-native applications. He writes practical, accessible guides to help
            developers master JavaScript and modern web development.</p>

        <h3>Connect with Bohdan:</h3>
        <ul>
            <li>Medium: @bohdaq</li>
            <li>LinkedIn: linkedin.com/in/bohdaq</li>
            <li>GitHub: github.com/bohdaq</li>
        </ul>
    </div>

    <!-- Copyright -->
    <div class="copyright page-break">
        <p><strong>Â© 2026 Bohdan Tsap. All rights reserved.</strong></p>
    </div>

</body>

</html>