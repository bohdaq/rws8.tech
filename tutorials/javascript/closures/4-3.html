<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9724DKC9BF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-9724DKC9BF');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Lesson 4.3: Performance Considerations - Optimize closure usage for better performance.">
    <meta name="keywords" content="JavaScript, Closures, Performance, Optimization">
    <meta name="author" content="bohdaq">
    <title>Lesson 4.3: Performance Considerations | bohdaq</title>
    <link rel="stylesheet" href="../../../styles.css">
    <link rel="canonical" href="https://rws8.tech/tutorials/javascript/closures/4-3.html">
    <link rel="stylesheet" href="../../../assets/prism/prism.css">
    <style>
        .lesson-content {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }
        .lesson-content h2 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        .lesson-content code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }
        .lesson-content ul, .lesson-content ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }
        .lesson-content li {
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }
        .lesson-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 2px solid var(--border-color);
        }
        .objectives-box {
            background-color: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
        .objectives-box h3 {
            margin-top: 0;
            color: var(--primary-color);
        }
        .key-takeaways {
            background-color: #f0f9ff;
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="../../../index.html" class="logo">bohdaq</a>
            <ul class="nav-links">
                <li><a href="../../../index.html">Home</a></li>
                <li><a href="../../../fullstack.html">Fullstack</a></li>
                <li><a href="../../../frontend.html">Frontend</a></li>
                <li><a href="../../../backend.html">Backend</a></li>
                <li><a href="../../../tutorials.html" class="active">Tutorials</a></li>
            </ul>
        </div>
    </nav>
    <section class="breadcrumbs">
        <div class="container">
            <nav aria-label="Breadcrumb">
                <a href="../../../index.html">Home</a>
                <span class="separator">›</span>
                <a href="../../../tutorials.html">Tutorials</a>
                <span class="separator">›</span>
                <a href="../index.html">JavaScript</a>
                <span class="separator">›</span>
                <a href="index.html">Closures</a>
                <span class="separator">›</span>
                <span class="current">Lesson</span>
            </nav>
        </div>
    </section>

    <header class="page-header">
        <div class="container">
            <h1>Lesson 4.3: Performance Considerations</h1>
            <p class="page-subtitle">JavaScript Closures Tutorial - Section 4: Advanced Concepts</p>
        </div>
    </header>

    <section class="content-section">
        <div class="container">
            <div class="lesson-content">
                <div class="objectives-box">
                    <h3>Learning Objectives</h3>
                    <ul>
                        <li>Understand the performance impact of closures</li>
                        <li>Learn optimization techniques</li>
                        <li>Know when to use closures vs alternatives</li>
                        <li>Apply performance best practices</li>
                    </ul>
                </div>

                <h2>The Performance Reality</h2>
                <p>
                    Good news: Modern JavaScript engines optimize closures heavily. In most cases, the performance impact is negligible. However, understanding the costs helps you make informed decisions.
                </p>

                <h2>Memory Cost of Closures</h2>
                <p>
                    Each closure instance maintains its own lexical environment:
                </p>

                <pre><code class="language-javascript">// Each counter has its own environment
function createCounter() {
    let count = 0;
    return () => ++count;
}

const counters = [];
for (let i = 0; i < 1000; i++) {
    counters.push(createCounter());
}

// 1000 separate environments in memory
// Each with its own 'count' variable</code></pre>

                <h2>Optimization 1: Share Common Data</h2>
                <pre><code class="language-javascript">// ❌ Each closure has its own copy
function createFormatter() {
    const config = {
        prefix: '[LOG]',
        dateFormat: 'ISO',
        colors: { info: 'blue', error: 'red' }
    };
    
    return (message) => {
        return `${config.prefix} ${message}`;
    };
}

// ✅ Share config across all closures
const sharedConfig = {
    prefix: '[LOG]',
    dateFormat: 'ISO',
    colors: { info: 'blue', error: 'red' }
};

function createFormatter() {
    return (message) => {
        return `${sharedConfig.prefix} ${message}`;
    };
}</code></pre>

                <h2>Optimization 2: Avoid Unnecessary Closures</h2>
                <pre><code class="language-javascript">// ❌ Creates new closure on every render
function Component() {
    return (
        <button onClick={() => console.log('clicked')}>
            Click me
        </button>
    );
}

// ✅ Reuse the same function
function handleClick() {
    console.log('clicked');
}

function Component() {
    return (
        <button onClick={handleClick}>
            Click me
        </button>
    );
}

// ✅ Or use closure only when needed
function Component({ userId }) {
    const handleClick = () => {
        console.log('User:', userId);
    };
    
    return (
        <button onClick={handleClick}>
            Click me
        </button>
    );
}</code></pre>

                <h2>Optimization 3: Limit Closure Scope</h2>
                <pre><code class="language-javascript">// ❌ Captures more than needed
function processData(largeArray) {
    const result = largeArray.map(x => x * 2);
    const sum = result.reduce((a, b) => a + b, 0);
    
    return function() {
        // Only needs sum, but captures largeArray and result too!
        return sum;
    };
}

// ✅ Only capture what's needed
function processData(largeArray) {
    const result = largeArray.map(x => x * 2);
    const sum = result.reduce((a, b) => a + b, 0);
    
    // largeArray and result go out of scope here
    return function() {
        return sum; // Only captures sum
    };
}</code></pre>

                <h2>Optimization 4: Use Prototype Methods</h2>
                <pre><code class="language-javascript">// ❌ Each instance has its own methods
function Counter(initial) {
    let count = initial;
    
    this.increment = function() {
        count++;
        return count;
    };
    
    this.decrement = function() {
        count--;
        return count;
    };
}

// ✅ Share methods on prototype
function Counter(initial) {
    this._count = initial;
}

Counter.prototype.increment = function() {
    this._count++;
    return this._count;
};

Counter.prototype.decrement = function() {
    this._count--;
    return this._count;
};

// Trade-off: No private variables, but better memory usage</code></pre>

                <h2>Optimization 5: Lazy Initialization</h2>
                <pre><code class="language-javascript">// ❌ Computes immediately even if never used
function createExpensiveResource() {
    const resource = computeExpensiveValue();
    
    return {
        getResource: () => resource
    };
}

// ✅ Compute only when needed
function createExpensiveResource() {
    let resource = null;
    let computed = false;
    
    return {
        getResource: () => {
            if (!computed) {
                resource = computeExpensiveValue();
                computed = true;
            }
            return resource;
        }
    };
}</code></pre>

                <h2>Benchmarking Closures</h2>
                <pre><code class="language-javascript">// Benchmark closure vs direct access
function benchmarkClosure() {
    let value = 0;
    
    const withClosure = () => value++;
    
    console.time('closure');
    for (let i = 0; i < 1000000; i++) {
        withClosure();
    }
    console.timeEnd('closure');
    
    console.time('direct');
    for (let i = 0; i < 1000000; i++) {
        value++;
    }
    console.timeEnd('direct');
}

benchmarkClosure();
// Modern engines: difference is minimal!</code></pre>

                <h2>When Closures Are Worth It</h2>
                <ul>
                    <li><strong>Data privacy</strong>: When you need truly private variables</li>
                    <li><strong>Configuration</strong>: Pre-configuring functions</li>
                    <li><strong>Event handlers</strong>: Maintaining state across events</li>
                    <li><strong>Callbacks</strong>: Passing context to async operations</li>
                    <li><strong>Memoization</strong>: Caching expensive computations</li>
                </ul>

                <h2>When to Avoid Closures</h2>
                <ul>
                    <li><strong>Hot paths</strong>: Code executed millions of times per second</li>
                    <li><strong>Large loops</strong>: Creating thousands of closures</li>
                    <li><strong>Simple getters/setters</strong>: Use properties instead</li>
                    <li><strong>No state needed</strong>: Use pure functions</li>
                </ul>

                <h2>Practical Example: Optimized Event Manager</h2>
                <pre><code class="language-javascript">// Optimized for performance
class EventManager {
    constructor() {
        this.listeners = new Map();
    }
    
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        this.listeners.get(event).add(callback);
        
        // Return bound unsubscribe (closure only when needed)
        return this.off.bind(this, event, callback);
    }
    
    off(event, callback) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            callbacks.delete(callback);
        }
    }
    
    emit(event, data) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            // Avoid creating closure in loop
            for (const callback of callbacks) {
                callback(data);
            }
        }
    }
}

const events = new EventManager();
const unsubscribe = events.on('data', console.log);
events.emit('data', 'test');
unsubscribe();</code></pre>

                <h2>Practical Example: Optimized Memoization</h2>
                <pre><code class="language-javascript">// Optimized memoization with size limit
function memoize(fn, maxSize = 100) {
    const cache = new Map();
    
    return function(...args) {
        // Use simple key for single arg, JSON for multiple
        const key = args.length === 1 ? args[0] : JSON.stringify(args);
        
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        const result = fn.apply(this, args);
        
        // Limit cache size
        if (cache.size >= maxSize) {
            const firstKey = cache.keys().next().value;
            cache.delete(firstKey);
        }
        
        cache.set(key, result);
        return result;
    };
}

const memoizedFn = memoize(expensiveFunction, 50);</code></pre>

                <h2>Performance Monitoring</h2>
                <pre><code class="language-javascript">// Monitor function performance
function measurePerformance(fn, name) {
    return function(...args) {
        const start = performance.now();
        const result = fn.apply(this, args);
        const end = performance.now();
        
        console.log(`${name} took ${(end - start).toFixed(2)}ms`);
        return result;
    };
}

const slowFunction = measurePerformance(
    () => {
        let sum = 0;
        for (let i = 0; i < 1000000; i++) {
            sum += i;
        }
        return sum;
    },
    'slowFunction'
);

slowFunction();</code></pre>

                <h2>Best Practices Summary</h2>

                <h3>DO:</h3>
                <ul>
                    <li>✅ Use closures for data privacy and encapsulation</li>
                    <li>✅ Share common data instead of duplicating</li>
                    <li>✅ Limit what closures capture</li>
                    <li>✅ Use lazy initialization for expensive resources</li>
                    <li>✅ Provide cleanup functions</li>
                    <li>✅ Profile before optimizing</li>
                </ul>

                <h3>DON'T:</h3>
                <ul>
                    <li>❌ Create closures in tight loops unnecessarily</li>
                    <li>❌ Capture large objects when only small parts are needed</li>
                    <li>❌ Forget to clean up event listeners and timers</li>
                    <li>❌ Optimize prematurely without measuring</li>
                    <li>❌ Sacrifice code clarity for micro-optimizations</li>
                </ul>

                <h2>The Bottom Line</h2>
                <p>
                    Modern JavaScript engines are incredibly good at optimizing closures. In most applications, closures are not a performance bottleneck. Focus on:
                </p>

                <ol>
                    <li><strong>Write clear, maintainable code first</strong></li>
                    <li><strong>Profile to find actual bottlenecks</strong></li>
                    <li><strong>Optimize only when necessary</strong></li>
                    <li><strong>Measure the impact of optimizations</strong></li>
                </ol>

                <h2>Real-World Performance Tips</h2>
                <pre><code class="language-javascript">// Tip 1: Reuse closures when possible
const handlers = {
    click: (e) => console.log('clicked', e),
    hover: (e) => console.log('hovered', e)
};

elements.forEach(el => {
    el.addEventListener('click', handlers.click);
    el.addEventListener('mouseover', handlers.hover);
});

// Tip 2: Use WeakMap for automatic cleanup
const privateData = new WeakMap();

function createObject(data) {
    const obj = {};
    privateData.set(obj, data);
    return obj;
}

// Tip 3: Batch operations
function batchProcess(items, batchSize = 100) {
    const batches = [];
    for (let i = 0; i < items.length; i += batchSize) {
        batches.push(items.slice(i, i + batchSize));
    }
    
    return batches.map(batch => 
        () => batch.forEach(processItem)
    );
}</code></pre>

                <div class="key-takeaways">
                    <h3>Key Takeaways</h3>
                    <ul>
                        <li>✅ Modern engines <strong>optimize closures heavily</strong></li>
                        <li>✅ Performance impact is usually <strong>negligible</strong></li>
                        <li>✅ <strong>Profile before optimizing</strong> - measure, don't guess</li>
                        <li>✅ Share common data, limit closure scope</li>
                        <li>✅ Clean up resources to prevent memory leaks</li>
                        <li>✅ <strong>Clarity over micro-optimizations</strong></li>
                        <li>✅ Use closures when they provide clear benefits</li>
                    </ul>
                </div>

                <h2>Congratulations!</h2>
                <p>
                    You've completed the JavaScript Closures tutorial! You now understand:
                </p>

                <ul>
                    <li>✅ What closures are and how they work</li>
                    <li>✅ Lexical scope and the scope chain</li>
                    <li>✅ Practical patterns: data privacy, factories, modules, currying</li>
                    <li>✅ Common use cases: events, timers, arrays, memoization</li>
                    <li>✅ Advanced concepts: loops, memory management, performance</li>
                </ul>

                <p>
                    Closures are a fundamental JavaScript feature that enables powerful patterns. Use them wisely, and they'll make your code more elegant, maintainable, and expressive.
                </p>

                <p>
                    <strong>Keep practicing!</strong> The best way to master closures is to use them in real projects. Start small, experiment, and gradually incorporate these patterns into your code.
                </p>

                <div class="lesson-nav">
                    <a href="4-2.html" class="btn btn-secondary">← Previous: Memory Management</a>
                    <a href="index.html" class="btn btn-primary">Back to Course Overview</a>
                </div>
            </div>
        </div>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2025 bohdaq. All rights reserved.</p>
            <div class="footer-links">
                <a href="https://github.com/bohdaq" target="_blank" rel="nofollow noopener">GitHub</a>
                <a href="https://www.linkedin.com/in/bohdaq/" target="_blank" rel="nofollow noopener">LinkedIn</a>
                <a href="https://crates.io/users/bohdaq" target="_blank" rel="nofollow noopener">crates.io</a>
                <a href="https://orcid.org/0000-0002-5221-5607" target="_blank" rel="nofollow noopener">ORCID</a>
            </div>
        </div>
    </footer>
    <script src="../../../assets/prism/prism.js"></script>
    <script src="../../../assets/prism/prism-javascript.js"></script>
</body>
</html>
