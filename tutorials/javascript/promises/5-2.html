<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9724DKC9BF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-9724DKC9BF');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Lesson 5.2: Retry Logic and Exponential Backoff - Build resilient async operations.">
    <meta name="keywords" content="JavaScript, Promises, Retry Logic, Exponential Backoff, Tutorial">
    <meta name="author" content="bohdaq">
    <title>Lesson 5.2: Retry Logic | bohdaq</title>
    <link rel="stylesheet" href="../../../styles.css">
    <link rel="canonical" href="https://rws8.tech/tutorials-javascript-promises-5-2.html">
    <link rel="stylesheet" href="../../../assets/prism/prism.css">
    <style>
        .lesson-content {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }
        .lesson-content h2 {
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        .lesson-content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        .lesson-content code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }
        .lesson-content ul, .lesson-content ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }
        .lesson-content li {
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }
        .lesson-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 2px solid var(--border-color);
        }
        .objectives-box {
            background-color: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
        .objectives-box h3 {
            margin-top: 0;
        }
        .key-takeaways {
            background-color: #f0f9ff;
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="../../../index.html" class="logo">bohdaq</a>
            <ul class="nav-links">
                <li><a href="../../../index.html">Home</a></li>
                <li><a href="../../../fullstack.html">Fullstack</a></li>
                <li><a href="../../../frontend.html">Frontend</a></li>
                <li><a href="../../../backend.html">Backend</a></li>
                <li><a href="../../../tutorials.html" class="active">Tutorials</a></li>
            </ul>
        </div>
    </nav>
    <section class="breadcrumbs">
        <div class="container">
            <nav aria-label="Breadcrumb">
                <a href="../../../index.html">Home</a>
                <span class="separator">›</span>
                <a href="../../../tutorials.html">Tutorials</a>
                <span class="separator">›</span>
                <a href="../index.html">JavaScript</a>
                <span class="separator">›</span>
                <a href="index.html">Promises</a>
                <span class="separator">›</span>
                <span class="current">Lesson</span>
            </nav>
        </div>
    </section>


    <header class="page-header">
        <div class="container">
            <h1>Lesson 5.2: Retry Logic and Exponential Backoff</h1>
            <p class="page-subtitle">JavaScript Promises Tutorial - Section 5: Advanced Patterns</p>
        </div>
    </header>

    <section class="content-section">
        <div class="lesson-content">
            <div class="objectives-box">
                <h3>Learning Objectives</h3>
                <ul>
                    <li>Implement retry mechanisms for failed operations</li>
                    <li>Master exponential backoff strategy</li>
                    <li>Handle transient failures gracefully</li>
                    <li>Build production-ready retry logic</li>
                </ul>
            </div>

            <h2>Why Retry Logic?</h2>
            <p>Network requests and external services can fail temporarily due to:</p>
            <ul>
                <li>Network hiccups</li>
                <li>Server overload</li>
                <li>Rate limiting</li>
                <li>Temporary service unavailability</li>
            </ul>
            <p><strong>Retry logic makes your application resilient to transient failures.</strong></p>

            <h2>Basic Retry Pattern</h2>

            <pre><code class="language-javascript">async function retry(fn, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === retries - 1) {
        throw error;
      }
      console.log(`Attempt ${i + 1} failed, retrying...`);
    }
  }
}

// Usage
const data = await retry(() => fetch('/api/data'), 3);</code></pre>

            <h2>Retry with Delay</h2>

            <pre><code class="language-javascript">async function retryWithDelay(fn, retries = 3, delay = 1000) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === retries - 1) {
        throw error;
      }
      
      console.log(`Attempt ${i + 1} failed, waiting ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage
const data = await retryWithDelay(
  () => fetch('/api/data'),
  3,
  1000
);</code></pre>

            <h2>Exponential Backoff</h2>

            <p>Exponential backoff increases the delay between retries exponentially, reducing server load:</p>

            <pre><code class="language-javascript">async function retryWithExponentialBackoff(
  fn,
  retries = 5,
  baseDelay = 1000,
  maxDelay = 30000
) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === retries - 1) {
        throw error;
      }
      
      // Calculate exponential delay: 1s, 2s, 4s, 8s, 16s...
      const delay = Math.min(baseDelay * Math.pow(2, i), maxDelay);
      
      console.log(`Attempt ${i + 1} failed, waiting ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage
const data = await retryWithExponentialBackoff(
  () => fetch('/api/data'),
  5,    // 5 retries
  1000, // Start with 1 second
  30000 // Max 30 seconds
);</code></pre>

            <h2>Exponential Backoff with Jitter</h2>

            <p>Add randomness to prevent thundering herd problem:</p>

            <pre><code class="language-javascript">async function retryWithJitter(
  fn,
  retries = 5,
  baseDelay = 1000,
  maxDelay = 30000
) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === retries - 1) {
        throw error;
      }
      
      // Exponential backoff with jitter
      const exponentialDelay = baseDelay * Math.pow(2, i);
      const jitter = Math.random() * exponentialDelay;
      const delay = Math.min(exponentialDelay + jitter, maxDelay);
      
      console.log(`Retry ${i + 1}/${retries} after ${Math.round(delay)}ms`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage
const data = await retryWithJitter(() => fetch('/api/data'));</code></pre>

            <h2>Conditional Retry</h2>

            <p>Only retry on specific error types:</p>

            <pre><code class="language-javascript">function isRetryableError(error) {
  // Retry on network errors and 5xx server errors
  return (
    error.name === 'NetworkError' ||
    (error.status >= 500 && error.status < 600) ||
    error.status === 429 // Rate limit
  );
}

async function retryOnCondition(fn, retries = 3, delay = 1000) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === retries - 1 || !isRetryableError(error)) {
        throw error;
      }
      
      console.log(`Retryable error, attempt ${i + 2}/${retries}`);
      await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
    }
  }
}

// Usage
const data = await retryOnCondition(async () => {
  const response = await fetch('/api/data');
  if (!response.ok) {
    const error = new Error('HTTP Error');
    error.status = response.status;
    throw error;
  }
  return response.json();
});</code></pre>

            <h2>Retry with Progress Callback</h2>

            <pre><code class="language-javascript">async function retryWithProgress(
  fn,
  retries = 3,
  onRetry = null
) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === retries - 1) {
        throw error;
      }
      
      if (onRetry) {
        onRetry(i + 1, retries, error);
      }
      
      const delay = 1000 * Math.pow(2, i);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage
const data = await retryWithProgress(
  () => fetch('/api/data'),
  3,
  (attempt, total, error) => {
    console.log(`Retry ${attempt}/${total}: ${error.message}`);
    updateUI(`Retrying... (${attempt}/${total})`);
  }
);</code></pre>

            <h2>Retry Class</h2>

            <pre><code class="language-javascript">class RetryStrategy {
  constructor(options = {}) {
    this.maxRetries = options.maxRetries || 3;
    this.baseDelay = options.baseDelay || 1000;
    this.maxDelay = options.maxDelay || 30000;
    this.useJitter = options.useJitter !== false;
    this.shouldRetry = options.shouldRetry || (() => true);
  }
  
  async execute(fn) {
    let lastError;
    
    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        
        if (attempt === this.maxRetries - 1 || !this.shouldRetry(error)) {
          throw error;
        }
        
        const delay = this.calculateDelay(attempt);
        console.log(`Retry ${attempt + 1}/${this.maxRetries} after ${delay}ms`);
        await this.sleep(delay);
      }
    }
    
    throw lastError;
  }
  
  calculateDelay(attempt) {
    let delay = this.baseDelay * Math.pow(2, attempt);
    
    if (this.useJitter) {
      delay += Math.random() * delay;
    }
    
    return Math.min(delay, this.maxDelay);
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Usage
const retry = new RetryStrategy({
  maxRetries: 5,
  baseDelay: 1000,
  maxDelay: 30000,
  useJitter: true,
  shouldRetry: (error) => error.status >= 500
});

const data = await retry.execute(() => fetch('/api/data'));</code></pre>

            <h2>Real-World Example: API Client with Retry</h2>

            <pre><code class="language-javascript">class APIClient {
  constructor(baseURL, retryOptions = {}) {
    this.baseURL = baseURL;
    this.retry = new RetryStrategy(retryOptions);
  }
  
  async request(endpoint, options = {}) {
    return await this.retry.execute(async () => {
      const url = `${this.baseURL}${endpoint}`;
      const response = await fetch(url, options);
      
      if (!response.ok) {
        const error = new Error(`HTTP ${response.status}`);
        error.status = response.status;
        error.response = response;
        throw error;
      }
      
      return await response.json();
    });
  }
  
  async get(endpoint) {
    return await this.request(endpoint);
  }
  
  async post(endpoint, data) {
    return await this.request(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }
}

// Usage
const api = new APIClient('https://api.example.com', {
  maxRetries: 3,
  baseDelay: 1000,
  shouldRetry: (error) => error.status >= 500 || error.status === 429
});

try {
  const users = await api.get('/users');
  console.log(users);
} catch (error) {
  console.error('All retries failed:', error);
}</code></pre>

            <h2>Retry with Circuit Breaker</h2>

            <pre><code class="language-javascript">class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    
    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
      console.log(`Circuit breaker OPEN for ${this.timeout}ms`);
    }
  }
}

// Combine retry with circuit breaker
const circuitBreaker = new CircuitBreaker(5, 60000);
const retry = new RetryStrategy({ maxRetries: 3 });

async function resilientFetch(url) {
  return await circuitBreaker.execute(async () => {
    return await retry.execute(() => fetch(url));
  });
}</code></pre>

            <h2>Best Practices</h2>

            <ol>
                <li><strong>Use exponential backoff</strong> to reduce server load</li>
                <li><strong>Add jitter</strong> to prevent thundering herd</li>
                <li><strong>Set maximum delays</strong> to avoid infinite waits</li>
                <li><strong>Only retry transient errors</strong> (network, 5xx)</li>
                <li><strong>Don't retry on client errors</strong> (4xx)</li>
                <li><strong>Log retry attempts</strong> for monitoring</li>
                <li><strong>Set reasonable retry limits</strong> (3-5 attempts)</li>
                <li><strong>Consider circuit breakers</strong> for failing services</li>
            </ol>

            <div class="key-takeaways">
                <h3>Key Takeaways</h3>
                <ul>
                    <li>✅ Retry logic makes applications <strong>resilient</strong></li>
                    <li>✅ Use <strong>exponential backoff</strong> to reduce load</li>
                    <li>✅ Add <strong>jitter</strong> to prevent synchronized retries</li>
                    <li>✅ Only retry <strong>transient failures</strong></li>
                    <li>✅ Combine with <strong>circuit breakers</strong> for better reliability</li>
                    <li>✅ Set <strong>maximum retry limits</strong> and delays</li>
                </ul>
            </div>

            <h2>Next Steps</h2>
            <p>Next, we'll learn about rate limiting to control request frequency!</p>

            <div class="lesson-nav">
                <a href="5-1.html" class="btn btn-secondary">← Previous: Promise Utilities</a>
                <a href="5-3.html" class="btn btn-primary">Next: Rate Limiting →</a>
            </div>
        </div>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2025 bohdaq. All rights reserved.</p>
            <div class="footer-links">
                <a href="https://github.com/bohdaq" target="_blank" rel="nofollow noopener">GitHub</a>
                <a href="https://crates.io/users/bohdaq" target="_blank" rel="nofollow noopener">crates.io</a>
                <a href="https://orcid.org/0000-0002-5221-5607" target="_blank" rel="nofollow noopener">ORCID</a>
            </div>
        </div>
    </footer>
    <script src="../../../assets/prism/prism.js"></script>
    <script src="../../../assets/prism/prism-javascript.js"></script>
</body>
</html>
