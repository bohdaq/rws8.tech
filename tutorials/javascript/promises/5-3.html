<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9724DKC9BF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-9724DKC9BF');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Lesson 5.3: Promise Queues and Rate Limiting - Control concurrent Promise execution.">
    <meta name="keywords" content="JavaScript, Promises, Rate Limiting, Queue, Concurrency, Tutorial">
    <meta name="author" content="bohdaq">
    <title>Lesson 5.3: Rate Limiting | bohdaq</title>
    <link rel="stylesheet" href="../../../styles.css">
    <link rel="canonical" href="https://rws8.tech/tutorials-javascript-promises-5-3.html">
    <link rel="stylesheet" href="../../../assets/prism/prism.css">
    <style>
        .lesson-content {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }
        .lesson-content h2 {
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        .lesson-content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        .lesson-content code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }
        .lesson-content ul, .lesson-content ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }
        .lesson-content li {
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }
        .lesson-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 2px solid var(--border-color);
        }
        .objectives-box {
            background-color: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
        .objectives-box h3 {
            margin-top: 0;
        }
        .key-takeaways {
            background-color: #f0f9ff;
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="../../../index.html" class="logo">bohdaq</a>
            <ul class="nav-links">
                <li><a href="../../../index.html">Home</a></li>
                <li><a href="../../../fullstack.html">Fullstack</a></li>
                <li><a href="../../../frontend.html">Frontend</a></li>
                <li><a href="../../../backend.html">Backend</a></li>
                <li><a href="../../../tutorials.html" class="active">Tutorials</a></li>
            </ul>
        </div>
    </nav>
    <section class="breadcrumbs">
        <div class="container">
            <nav aria-label="Breadcrumb">
                <a href="../../../index.html">Home</a>
                <span class="separator">›</span>
                <a href="../../../tutorials.html">Tutorials</a>
                <span class="separator">›</span>
                <a href="../index.html">JavaScript</a>
                <span class="separator">›</span>
                <a href="index.html">Promises</a>
                <span class="separator">›</span>
                <span class="current">Lesson</span>
            </nav>
        </div>
    </section>


    <header class="page-header">
        <div class="container">
            <h1>Lesson 5.3: Promise Queues and Rate Limiting</h1>
            <p class="page-subtitle">JavaScript Promises Tutorial - Section 5: Advanced Patterns</p>
        </div>
    </header>

    <section class="content-section">
        <div class="lesson-content">
            <div class="objectives-box">
                <h3>Learning Objectives</h3>
                <ul>
                    <li>Control concurrent Promise execution</li>
                    <li>Implement Promise queues</li>
                    <li>Master rate limiting patterns</li>
                    <li>Prevent API throttling</li>
                </ul>
            </div>

            <h2>Why Rate Limiting?</h2>
            <p>Rate limiting prevents:</p>
            <ul>
                <li>API throttling and bans</li>
                <li>Server overload</li>
                <li>Resource exhaustion</li>
                <li>Excessive costs</li>
            </ul>

            <h2>Simple Concurrency Limiter</h2>

            <pre><code class="language-javascript">async function limitConcurrency(tasks, limit) {
  const results = [];
  const executing = [];
  
  for (const task of tasks) {
    const promise = Promise.resolve().then(() => task());
    results.push(promise);
    
    if (limit <= tasks.length) {
      const e = promise.then(() => {
        executing.splice(executing.indexOf(e), 1);
      });
      executing.push(e);
      
      if (executing.length >= limit) {
        await Promise.race(executing);
      }
    }
  }
  
  return Promise.all(results);
}

// Usage: Max 3 concurrent operations
const tasks = userIds.map(id => () => fetchUser(id));
const results = await limitConcurrency(tasks, 3);</code></pre>

            <h2>Promise Queue</h2>

            <pre><code class="language-javascript">class PromiseQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async add(fn) {
    while (this.running >= this.concurrency) {
      await new Promise(resolve => this.queue.push(resolve));
    }
    
    this.running++;
    
    try {
      return await fn();
    } finally {
      this.running--;
      const resolve = this.queue.shift();
      if (resolve) resolve();
    }
  }
}

// Usage
const queue = new PromiseQueue(3);

const results = await Promise.all(
  userIds.map(id => queue.add(() => fetchUser(id)))
);</code></pre>

            <h2>Rate Limiter (Requests per Second)</h2>

            <pre><code class="language-javascript">class RateLimiter {
  constructor(requestsPerSecond) {
    this.requestsPerSecond = requestsPerSecond;
    this.interval = 1000 / requestsPerSecond;
    this.lastCallTime = 0;
  }
  
  async execute(fn) {
    const now = Date.now();
    const timeSinceLastCall = now - this.lastCallTime;
    
    if (timeSinceLastCall < this.interval) {
      const delay = this.interval - timeSinceLastCall;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    this.lastCallTime = Date.now();
    return await fn();
  }
}

// Usage: 10 requests per second
const limiter = new RateLimiter(10);

for (const id of userIds) {
  const user = await limiter.execute(() => fetchUser(id));
  console.log(user);
}</code></pre>

            <h2>Token Bucket Algorithm</h2>

            <pre><code class="language-javascript">class TokenBucket {
  constructor(capacity, refillRate) {
    this.capacity = capacity;
    this.tokens = capacity;
    this.refillRate = refillRate; // tokens per second
    this.lastRefill = Date.now();
  }
  
  refill() {
    const now = Date.now();
    const timePassed = (now - this.lastRefill) / 1000;
    const tokensToAdd = timePassed * this.refillRate;
    
    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
  
  async consume(tokens = 1) {
    this.refill();
    
    while (this.tokens < tokens) {
      const waitTime = ((tokens - this.tokens) / this.refillRate) * 1000;
      await new Promise(resolve => setTimeout(resolve, waitTime));
      this.refill();
    }
    
    this.tokens -= tokens;
  }
  
  async execute(fn, tokens = 1) {
    await this.consume(tokens);
    return await fn();
  }
}

// Usage: 100 token capacity, refill 10 per second
const bucket = new TokenBucket(100, 10);

for (const id of userIds) {
  const user = await bucket.execute(() => fetchUser(id));
  console.log(user);
}</code></pre>

            <h2>Sliding Window Rate Limiter</h2>

            <pre><code class="language-javascript">class SlidingWindowLimiter {
  constructor(maxRequests, windowMs) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
    this.requests = [];
  }
  
  async execute(fn) {
    const now = Date.now();
    
    // Remove old requests outside window
    this.requests = this.requests.filter(
      time => now - time < this.windowMs
    );
    
    // Wait if at limit
    while (this.requests.length >= this.maxRequests) {
      const oldestRequest = this.requests[0];
      const waitTime = this.windowMs - (now - oldestRequest);
      
      if (waitTime > 0) {
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
      
      // Refresh after waiting
      const currentTime = Date.now();
      this.requests = this.requests.filter(
        time => currentTime - time < this.windowMs
      );
    }
    
    this.requests.push(Date.now());
    return await fn();
  }
}

// Usage: 100 requests per minute
const limiter = new SlidingWindowLimiter(100, 60000);

for (const id of userIds) {
  const user = await limiter.execute(() => fetchUser(id));
  console.log(user);
}</code></pre>

            <h2>Combined Queue and Rate Limiter</h2>

            <pre><code class="language-javascript">class ThrottledQueue {
  constructor(concurrency, requestsPerSecond) {
    this.queue = new PromiseQueue(concurrency);
    this.limiter = new RateLimiter(requestsPerSecond);
  }
  
  async add(fn) {
    return await this.queue.add(async () => {
      return await this.limiter.execute(fn);
    });
  }
}

// Usage: Max 5 concurrent, 10 per second
const throttledQueue = new ThrottledQueue(5, 10);

const results = await Promise.all(
  userIds.map(id => throttledQueue.add(() => fetchUser(id)))
);</code></pre>

            <h2>Real-World Example: API Client with Rate Limiting</h2>

            <pre><code class="language-javascript">class RateLimitedAPIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.limiter = new TokenBucket(
      options.capacity || 100,
      options.refillRate || 10
    );
  }
  
  async request(endpoint, options = {}) {
    return await this.limiter.execute(async () => {
      const url = `${this.baseURL}${endpoint}`;
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      return await response.json();
    });
  }
  
  async batchRequest(endpoints, batchSize = 10) {
    const results = [];
    
    for (let i = 0; i < endpoints.length; i += batchSize) {
      const batch = endpoints.slice(i, i + batchSize);
      
      const batchResults = await Promise.all(
        batch.map(endpoint => this.request(endpoint))
      );
      
      results.push(...batchResults);
    }
    
    return results;
  }
}

// Usage
const api = new RateLimitedAPIClient('https://api.example.com', {
  capacity: 100,
  refillRate: 10
});

const users = await api.batchRequest(
  userIds.map(id => `/users/${id}`),
  10
);</code></pre>

            <h2>Adaptive Rate Limiting</h2>

            <pre><code class="language-javascript">class AdaptiveRateLimiter {
  constructor(initialRate = 10) {
    this.rate = initialRate;
    this.minRate = 1;
    this.maxRate = 100;
    this.successCount = 0;
    this.failureCount = 0;
  }
  
  async execute(fn) {
    const delay = 1000 / this.rate;
    await new Promise(resolve => setTimeout(resolve, delay));
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      if (error.status === 429) { // Rate limited
        this.onRateLimit();
      } else {
        this.onFailure();
      }
      throw error;
    }
  }
  
  onSuccess() {
    this.successCount++;
    
    // Gradually increase rate after successes
    if (this.successCount >= 10) {
      this.rate = Math.min(this.rate * 1.1, this.maxRate);
      this.successCount = 0;
      console.log(`Rate increased to ${this.rate.toFixed(1)}/s`);
    }
  }
  
  onRateLimit() {
    // Aggressively decrease on rate limit
    this.rate = Math.max(this.rate * 0.5, this.minRate);
    this.successCount = 0;
    console.log(`Rate limited! Decreased to ${this.rate.toFixed(1)}/s`);
  }
  
  onFailure() {
    this.failureCount++;
    
    if (this.failureCount >= 3) {
      this.rate = Math.max(this.rate * 0.8, this.minRate);
      this.failureCount = 0;
      console.log(`Rate decreased to ${this.rate.toFixed(1)}/s`);
    }
  }
}

// Usage
const limiter = new AdaptiveRateLimiter(10);

for (const id of userIds) {
  try {
    const user = await limiter.execute(() => fetchUser(id));
    console.log(user);
  } catch (error) {
    console.error(`Failed to fetch user ${id}`);
  }
}</code></pre>

            <h2>Priority Queue</h2>

            <pre><code class="language-javascript">class PriorityQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async add(fn, priority = 0) {
    return new Promise((resolve, reject) => {
      this.queue.push({ fn, priority, resolve, reject });
      this.queue.sort((a, b) => b.priority - a.priority);
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { fn, resolve, reject } = this.queue.shift();
    
    try {
      const result = await fn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
}

// Usage
const queue = new PriorityQueue(3);

// High priority tasks
queue.add(() => fetchCriticalData(), 10);

// Normal priority
queue.add(() => fetchUser(1), 5);

// Low priority
queue.add(() => fetchAnalytics(), 1);</code></pre>

            <h2>Best Practices</h2>

            <ol>
                <li><strong>Respect API limits</strong> - Stay below documented limits</li>
                <li><strong>Use exponential backoff</strong> on rate limit errors</li>
                <li><strong>Batch requests</strong> when possible</li>
                <li><strong>Cache results</strong> to reduce requests</li>
                <li><strong>Monitor rate limit headers</strong> from APIs</li>
                <li><strong>Implement adaptive limiting</strong> for dynamic adjustment</li>
                <li><strong>Use priority queues</strong> for important tasks</li>
            </ol>

            <div class="key-takeaways">
                <h3>Key Takeaways</h3>
                <ul>
                    <li>✅ Rate limiting prevents <strong>API throttling</strong></li>
                    <li>✅ Use <strong>Promise queues</strong> to control concurrency</li>
                    <li>✅ <strong>Token bucket</strong> algorithm for flexible rate limiting</li>
                    <li>✅ <strong>Sliding window</strong> for precise request counting</li>
                    <li>✅ <strong>Adaptive limiting</strong> adjusts to API behavior</li>
                    <li>✅ Combine with <strong>retry logic</strong> for resilience</li>
                </ul>
            </div>

            <h2>Next Steps</h2>
            <p>Next, we'll learn about cancellable Promises using AbortController!</p>

            <div class="lesson-nav">
                <a href="5-2.html" class="btn btn-secondary">← Previous: Retry Logic</a>
                <a href="5-4.html" class="btn btn-primary">Next: Cancellable Promises →</a>
            </div>
        </div>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2025 bohdaq. All rights reserved.</p>
            <div class="footer-links">
                <a href="https://github.com/bohdaq" target="_blank" rel="nofollow noopener">GitHub</a>
                <a href="https://crates.io/users/bohdaq" target="_blank" rel="nofollow noopener">crates.io</a>
                <a href="https://orcid.org/0000-0002-5221-5607" target="_blank" rel="nofollow noopener">ORCID</a>
            </div>
        </div>
    </footer>
    <script src="../../../assets/prism/prism.js"></script>
    <script src="../../../assets/prism/prism-javascript.js"></script>
</body>
</html>
