<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9724DKC9BF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-9724DKC9BF');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn JavaScript Inheritance - Master prototypal inheritance, ES6 classes, the prototype chain, and object-oriented programming patterns.">
    <meta name="keywords" content="JavaScript inheritance, prototypal inheritance, ES6 classes, prototype chain, extends, super, JavaScript OOP">
    <meta name="author" content="bohdaq">
    <title>JavaScript Inheritance | bohdaq</title>
    <link rel="stylesheet" href="../../../styles.css">
    <link rel="canonical" href="https://rws8.tech/tutorials/javascript/inheritance/lesson-1.html">
    <link rel="stylesheet" href="../../../assets/prism/prism.css">
    <style>
        .lesson-content {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }
        .lesson-content h2 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        .lesson-content code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }
        .lesson-content ul, .lesson-content ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }
        .lesson-content li {
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }
        .lesson-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 2px solid var(--border-color);
        }
        .objectives-box {
            background-color: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
        .objectives-box h3 {
            margin-top: 0;
            color: var(--primary-color);
        }
        .key-takeaways {
            background-color: #f0f9ff;
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="../../../index.html" class="logo">bohdaq</a>
            <ul class="nav-links">
                <li><a href="../../../index.html">Home</a></li>
                <li><a href="../../../fullstack.html">Fullstack</a></li>
                <li><a href="../../../frontend.html">Frontend</a></li>
                <li><a href="../../../backend.html">Backend</a></li>
                <li><a href="../../../tutorials.html" class="active">Tutorials</a></li>
            </ul>
        </div>
    </nav>

    <section class="breadcrumbs">
        <div class="container">
            <nav aria-label="Breadcrumb">
                <a href="../../../index.html">Home</a>
                <span class="separator">›</span>
                <a href="../../../tutorials.html">Tutorials</a>
                <span class="separator">›</span>
                <a href="../index.html">JavaScript</a>
                <span class="separator">›</span>
                <a href="index.html">Inheritance</a>
                <span class="separator">›</span>
                <span class="current">Lesson</span>
            </nav>
        </div>
    </section>

    <header class="page-header">
        <div class="container">
            <h1>JavaScript Inheritance</h1>
            <p class="page-subtitle">Master Prototypal Inheritance and ES6 Classes</p>
        </div>
    </header>

    <section class="content-section">
        <div class="container">
            <div class="lesson-content">
                <div class="objectives-box">
                    <h3>Learning Objectives</h3>
                    <ul>
                        <li>Understand prototypal inheritance and the prototype chain</li>
                        <li>Master ES6 class syntax and inheritance</li>
                        <li>Use super to call parent methods</li>
                        <li>Implement method overriding</li>
                        <li>Apply inheritance to real-world problems</li>
                    </ul>
                </div>

                <h2>What is Inheritance?</h2>
                <p>Inheritance is a mechanism that allows one object to acquire properties and methods from another object. It's a fundamental concept in object-oriented programming that promotes code reuse and establishes relationships between objects.</p>

                <p>Unlike classical languages like Java or C++ that use class-based inheritance, JavaScript uses <strong>prototypal inheritance</strong>. Every object in JavaScript has an internal link to another object called its prototype. When you try to access a property on an object, JavaScript first looks at the object itself, then walks up the prototype chain until it finds the property or reaches the end of the chain.</p>

                <pre><code class="language-javascript">// Simple prototype chain example
const animal = {
    eats: true,
    walk() {
        console.log('Animal walks');
    }
};

const rabbit = {
    jumps: true
};

// Set animal as the prototype of rabbit
rabbit.__proto__ = animal;

console.log(rabbit.eats);  // true (inherited from animal)
console.log(rabbit.jumps); // true (own property)
rabbit.walk();             // "Animal walks" (inherited method)</code></pre>

                <p>When we access <code>rabbit.eats</code>, JavaScript doesn't find it on the rabbit object, so it looks at rabbit's prototype (animal) and finds it there. This is the prototype chain in action.</p>

                <h2>Constructor Functions and Prototypes</h2>
                <p>Before ES6 classes, JavaScript developers used constructor functions and prototypes to implement inheritance:</p>

                <pre><code class="language-javascript">// Constructor function
function Animal(name) {
    this.name = name;
}

// Add method to prototype
Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

// Create instance
const dog = new Animal('Rex');
dog.speak(); // "Rex makes a sound"

// Check prototype chain
console.log(dog.__proto__ === Animal.prototype); // true
console.log(Animal.prototype.constructor === Animal); // true</code></pre>

                <p>When you use <code>new Animal('Rex')</code>, JavaScript creates a new object and sets its prototype to <code>Animal.prototype</code>. This is how methods defined on the prototype are shared across all instances.</p>

                <h3>Implementing Inheritance with Constructor Functions</h3>
                <pre><code class="language-javascript">// Parent constructor
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

// Child constructor
function Dog(name, breed) {
    Animal.call(this, name); // Call parent constructor
    this.breed = breed;
}

// Set up inheritance
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Add child-specific method
Dog.prototype.bark = function() {
    console.log(`${this.name} barks!`);
};

// Override parent method
Dog.prototype.speak = function() {
    console.log(`${this.name} barks loudly`);
};

const rex = new Dog('Rex', 'German Shepherd');
rex.speak(); // "Rex barks loudly"
rex.bark();  // "Rex barks!"</code></pre>

                <p>This pattern works but is verbose and error-prone. That's why ES6 introduced class syntax.</p>

                <h2>ES6 Classes: Modern Inheritance</h2>
                <p>ES6 classes provide a cleaner, more intuitive syntax for creating objects and implementing inheritance. Under the hood, they still use prototypes, but the syntax is much more readable:</p>

                <pre><code class="language-javascript">class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log(`${this.name} makes a sound`);
    }
    
    move() {
        console.log(`${this.name} moves`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Call parent constructor
        this.breed = breed;
    }
    
    // Override parent method
    speak() {
        console.log(`${this.name} barks`);
    }
    
    // Add new method
    fetch() {
        console.log(`${this.name} fetches the ball`);
    }
}

const rex = new Dog('Rex', 'German Shepherd');
rex.speak();  // "Rex barks"
rex.move();   // "Rex moves" (inherited)
rex.fetch();  // "Rex fetches the ball"</code></pre>

                <p>The <code>extends</code> keyword sets up the prototype chain, and <code>super()</code> calls the parent constructor. This is much cleaner than the constructor function approach.</p>

                <h2>The super Keyword</h2>
                <p>The <code>super</code> keyword is used to call methods on a parent class. It's essential for accessing parent functionality in child classes:</p>

                <pre><code class="language-javascript">class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} makes a sound`;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // MUST call super() before using 'this'
        this.breed = breed;
    }
    
    speak() {
        // Call parent method and extend it
        const parentMessage = super.speak();
        return `${parentMessage} - specifically, a bark!`;
    }
}

const dog = new Dog('Buddy', 'Golden Retriever');
console.log(dog.speak()); // "Buddy makes a sound - specifically, a bark!"</code></pre>

                <p><strong>Important:</strong> In a child class constructor, you must call <code>super()</code> before accessing <code>this</code>. This is because the parent constructor needs to initialize the object first.</p>

                <h2>Method Overriding</h2>
                <p>Child classes can override parent methods to provide specialized behavior:</p>

                <pre><code class="language-javascript">class Shape {
    constructor(color) {
        this.color = color;
    }
    
    draw() {
        console.log(`Drawing a ${this.color} shape`);
    }
    
    getArea() {
        return 0; // Default implementation
    }
}

class Circle extends Shape {
    constructor(color, radius) {
        super(color);
        this.radius = radius;
    }
    
    // Override draw method
    draw() {
        console.log(`Drawing a ${this.color} circle with radius ${this.radius}`);
    }
    
    // Override getArea method
    getArea() {
        return Math.PI * this.radius ** 2;
    }
}

class Rectangle extends Shape {
    constructor(color, width, height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    draw() {
        console.log(`Drawing a ${this.color} rectangle ${this.width}x${this.height}`);
    }
    
    getArea() {
        return this.width * this.height;
    }
}

const circle = new Circle('red', 5);
const rectangle = new Rectangle('blue', 10, 20);

circle.draw();              // "Drawing a red circle with radius 5"
console.log(circle.getArea());    // 78.54...

rectangle.draw();           // "Drawing a blue rectangle 10x20"
console.log(rectangle.getArea()); // 200</code></pre>

                <h2>Real-World Example: User Roles</h2>
                <p>Let's build a practical user management system using inheritance:</p>

                <pre><code class="language-javascript">class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
        this.createdAt = new Date();
    }
    
    getInfo() {
        return `${this.name} (${this.email})`;
    }
    
    canEdit(resource) {
        return false; // Default: no edit permission
    }
    
    canDelete(resource) {
        return false; // Default: no delete permission
    }
}

class Admin extends User {
    constructor(name, email, department) {
        super(name, email);
        this.department = department;
        this.role = 'admin';
    }
    
    canEdit(resource) {
        return true; // Admins can edit everything
    }
    
    canDelete(resource) {
        return true; // Admins can delete everything
    }
    
    getInfo() {
        return `${super.getInfo()} - Admin (${this.department})`;
    }
}

class Moderator extends User {
    constructor(name, email, permissions) {
        super(name, email);
        this.permissions = permissions;
        this.role = 'moderator';
    }
    
    canEdit(resource) {
        return this.permissions.includes('edit');
    }
    
    canDelete(resource) {
        return this.permissions.includes('delete');
    }
    
    getInfo() {
        return `${super.getInfo()} - Moderator`;
    }
}

// Usage
const regularUser = new User('Alice', 'alice@example.com');
const admin = new Admin('Bob', 'bob@example.com', 'IT');
const moderator = new Moderator('Charlie', 'charlie@example.com', ['edit']);

console.log(regularUser.getInfo()); // "Alice (alice@example.com)"
console.log(admin.getInfo());       // "Bob (bob@example.com) - Admin (IT)"
console.log(moderator.getInfo());   // "Charlie (charlie@example.com) - Moderator"

console.log(regularUser.canEdit());  // false
console.log(admin.canEdit());        // true
console.log(moderator.canEdit());    // true
console.log(moderator.canDelete());  // false</code></pre>

                <h2>The Prototype Chain</h2>
                <p>Understanding the prototype chain is crucial for mastering JavaScript inheritance:</p>

                <pre><code class="language-javascript">class Animal {
    speak() {
        return 'sound';
    }
}

class Dog extends Animal {
    bark() {
        return 'woof';
    }
}

const dog = new Dog();

// Prototype chain:
// dog -> Dog.prototype -> Animal.prototype -> Object.prototype -> null

console.log(dog.__proto__ === Dog.prototype);                    // true
console.log(Dog.prototype.__proto__ === Animal.prototype);       // true
console.log(Animal.prototype.__proto__ === Object.prototype);    // true
console.log(Object.prototype.__proto__);                         // null

// Check if object is instance of class
console.log(dog instanceof Dog);     // true
console.log(dog instanceof Animal);  // true
console.log(dog instanceof Object);  // true

// Check if property exists
console.log(dog.hasOwnProperty('bark')); // false (it's on prototype)
console.log('bark' in dog);              // true (checks prototype chain)</code></pre>

                <h2>Static Methods and Properties</h2>
                <p>Static members belong to the class itself, not instances:</p>

                <pre><code class="language-javascript">class MathHelper {
    static PI = 3.14159;
    
    static add(a, b) {
        return a + b;
    }
    
    static multiply(a, b) {
        return a * b;
    }
}

// Call static methods on the class
console.log(MathHelper.add(5, 3));      // 8
console.log(MathHelper.multiply(4, 2)); // 8
console.log(MathHelper.PI);             // 3.14159

// Static methods are NOT available on instances
const helper = new MathHelper();
// helper.add(1, 2); // Error: helper.add is not a function</code></pre>

                <h3>Static Methods in Inheritance</h3>
                <pre><code class="language-javascript">class Animal {
    static kingdom = 'Animalia';
    
    static getKingdom() {
        return this.kingdom;
    }
}

class Dog extends Animal {
    static breed = 'Canis familiaris';
    
    static getBreed() {
        return this.breed;
    }
}

console.log(Animal.getKingdom()); // "Animalia"
console.log(Dog.getKingdom());    // "Animalia" (inherited)
console.log(Dog.getBreed());      // "Canis familiaris"</code></pre>

                <h2>Common Pitfalls</h2>

                <h3>1. Forgetting super() in Constructor</h3>
                <pre><code class="language-javascript">// Bad - will throw error
class Dog extends Animal {
    constructor(name, breed) {
        this.breed = breed; // Error! Must call super() first
        super(name);
    }
}

// Good
class Dog extends Animal {
    constructor(name, breed) {
        super(name);        // Call super() first
        this.breed = breed;
    }
}</code></pre>

                <h3>2. Modifying Shared Prototype Properties</h3>
                <pre><code class="language-javascript">// Bad - array is shared across all instances
class Team {
    constructor(name) {
        this.name = name;
    }
}
Team.prototype.members = []; // Shared!

const team1 = new Team('A');
const team2 = new Team('B');

team1.members.push('Alice');
console.log(team2.members); // ['Alice'] - Oops!

// Good - array is instance-specific
class Team {
    constructor(name) {
        this.name = name;
        this.members = []; // Each instance gets its own array
    }
}</code></pre>

                <h3>3. Overriding Without Calling super</h3>
                <pre><code class="language-javascript">class Animal {
    constructor(name) {
        this.name = name;
        this.energy = 100;
    }
}

// Bad - loses parent initialization
class Dog extends Animal {
    constructor(name, breed) {
        // Forgot super()!
        this.breed = breed;
    }
}

// Good - preserves parent initialization
class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Initializes name and energy
        this.breed = breed;
    }
}</code></pre>

                <h2>Best Practices</h2>

                <h3>1. Favor Composition Over Inheritance</h3>
                <p>Don't create deep inheritance hierarchies. Often, composition (combining objects) is better than inheritance:</p>

                <pre><code class="language-javascript">// Instead of deep inheritance
class Animal {}
class Mammal extends Animal {}
class Dog extends Mammal {}
class GoldenRetriever extends Dog {} // Too deep!

// Consider composition
class Dog {
    constructor(name) {
        this.name = name;
        this.abilities = {
            canSwim: new SwimmingAbility(),
            canFetch: new FetchingAbility()
        };
    }
}</code></pre>

                <h3>2. Keep Inheritance Hierarchies Shallow</h3>
                <p>Limit inheritance to 2-3 levels maximum. Deep hierarchies are hard to maintain and understand.</p>

                <h3>3. Use instanceof Carefully</h3>
                <pre><code class="language-javascript">// instanceof checks the prototype chain
class Animal {}
class Dog extends Animal {}

const dog = new Dog();
console.log(dog instanceof Dog);    // true
console.log(dog instanceof Animal); // true

// But be careful with cross-realm objects
// (objects from different iframes/windows)</code></pre>

                <h3>4. Document Your Class Hierarchy</h3>
                <p>Use JSDoc to document inheritance relationships:</p>

                <pre><code class="language-javascript">/**
 * Base class for all animals
 */
class Animal {
    constructor(name) {
        this.name = name;
    }
}

/**
 * Dog class
 * @extends Animal
 */
class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
}</code></pre>

                <h2>When to Use Inheritance</h2>

                <p><strong>Use inheritance when:</strong></p>
                <ul>
                    <li>You have a clear "is-a" relationship (Dog is-a Animal)</li>
                    <li>Child classes are specialized versions of the parent</li>
                    <li>You want to share common behavior across related classes</li>
                    <li>You're modeling real-world hierarchies</li>
                </ul>

                <p><strong>Avoid inheritance when:</strong></p>
                <ul>
                    <li>You have a "has-a" relationship (use composition instead)</li>
                    <li>The hierarchy would be more than 3 levels deep</li>
                    <li>Classes don't share meaningful behavior</li>
                    <li>You're just trying to reuse code (consider mixins or composition)</li>
                </ul>

                <h2>Key Takeaways</h2>
                <ul>
                    <li>JavaScript uses prototypal inheritance, not classical inheritance</li>
                    <li>ES6 classes provide clean syntax but use prototypes under the hood</li>
                    <li>Use <code>extends</code> to create child classes</li>
                    <li>Always call <code>super()</code> before using <code>this</code> in child constructors</li>
                    <li>Use <code>super.method()</code> to call parent methods</li>
                    <li>Child classes can override parent methods</li>
                    <li>Keep inheritance hierarchies shallow (2-3 levels max)</li>
                    <li>Favor composition over inheritance for complex relationships</li>
                    <li>Static methods belong to the class, not instances</li>
                    <li>Understand the prototype chain for debugging</li>
                </ul>

                <div class="lesson-nav">
                    <a href="index.html" class="btn btn-secondary">← Back to Overview</a>
                    <a href="../index.html" class="btn btn-secondary">All JavaScript Tutorials →</a>
                </div>
            </div>
        </div>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2025 bohdaq. All rights reserved.</p>
            <div class="footer-links">
                <a href="https://github.com/bohdaq" target="_blank" rel="nofollow noopener">GitHub</a>
                <a href="https://crates.io/users/bohdaq" target="_blank" rel="nofollow noopener">crates.io</a>
                <a href="https://orcid.org/0000-0002-5221-5607" target="_blank" rel="nofollow noopener">ORCID</a>
            </div>
        </div>
    </footer>

    <script src="../../../assets/prism/prism.js"></script>
</body>
</html>
